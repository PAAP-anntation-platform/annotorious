{"version":3,"file":"annotorious-core.es.js","sources":["../../../node_modules/dequal/lite/index.mjs","../../../node_modules/svelte/src/runtime/internal/utils.js","../../../node_modules/svelte/src/runtime/store/index.js","../src/state/Hover.ts","../src/state/Selection.ts","../../../node_modules/uuid/dist/esm-browser/rng.js","../../../node_modules/uuid/dist/esm-browser/stringify.js","../../../node_modules/uuid/dist/esm-browser/native.js","../../../node_modules/uuid/dist/esm-browser/v4.js","../src/utils/annotationUtils.ts","../src/utils/diffAnnotations.ts","../src/state/StoreObserver.ts","../src/state/Store.ts","../src/state/SvelteStore.ts","../../../node_modules/nanoevents/index.js","../src/state/UndoStack.ts","../src/state/Viewport.ts","../src/lifecycle/Lifecycle.ts","../src/model/FormatAdapter.ts","../src/model/Annotator.ts","../../../node_modules/nanoid/url-alphabet/index.js","../../../node_modules/nanoid/index.browser.js","../src/model/User.ts","../src/model/W3CAnnotation.ts","../src/presence/ColorPalette.ts","../src/presence/AppearanceProvider.ts","../src/presence/PresenceState.ts"],"sourcesContent":["var has = Object.prototype.hasOwnProperty;\n\nexport function dequal(foo, bar) {\n\tvar ctor, len;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","/** @returns {void} */\nexport function noop() {}\n\nexport const identity = (x) => x;\n\n/**\n * @template T\n * @template S\n * @param {T} tar\n * @param {S} src\n * @returns {T & S}\n */\nexport function assign(tar, src) {\n\t// @ts-ignore\n\tfor (const k in src) tar[k] = src[k];\n\treturn /** @type {T & S} */ (tar);\n}\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n/**\n * @param {any} value\n * @returns {value is PromiseLike<any>}\n */\nexport function is_promise(value) {\n\treturn (\n\t\t!!value &&\n\t\t(typeof value === 'object' || typeof value === 'function') &&\n\t\ttypeof (/** @type {any} */ (value).then) === 'function'\n\t);\n}\n\n/** @returns {void} */\nexport function add_location(element, file, line, column, char) {\n\telement.__svelte_meta = {\n\t\tloc: { file, line, column, char }\n\t};\n}\n\nexport function run(fn) {\n\treturn fn();\n}\n\nexport function blank_object() {\n\treturn Object.create(null);\n}\n\n/**\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function run_all(fns) {\n\tfns.forEach(run);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\n/** @returns {boolean} */\nexport function safe_not_equal(a, b) {\n\treturn a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';\n}\n\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nexport function src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\tif (!src_url_equal_anchor) {\n\t\tsrc_url_equal_anchor = document.createElement('a');\n\t}\n\t// This is actually faster than doing URL(..).href\n\tsrc_url_equal_anchor.href = url;\n\treturn element_src === src_url_equal_anchor.href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nexport function srcset_url_equal(element_srcset, srcset) {\n\tconst element_urls = split_srcset(element_srcset.srcset);\n\tconst urls = split_srcset(srcset || '');\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/** @returns {boolean} */\nexport function not_equal(a, b) {\n\treturn a != a ? b == b : a !== b;\n}\n\n/** @returns {boolean} */\nexport function is_empty(obj) {\n\treturn Object.keys(obj).length === 0;\n}\n\n/** @returns {void} */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\n\t}\n}\n\nexport function subscribe(store, ...callbacks) {\n\tif (store == null) {\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(undefined);\n\t\t}\n\t\treturn noop;\n\t}\n\tconst unsub = store.subscribe(...callbacks);\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {import('../store/public.js').Readable<T>} store\n * @returns {T}\n */\nexport function get_store_value(store) {\n\tlet value;\n\tsubscribe(store, (_) => (value = _))();\n\treturn value;\n}\n\n/** @returns {void} */\nexport function component_subscribe(component, store, callback) {\n\tcomponent.$$.on_destroy.push(subscribe(store, callback));\n}\n\nexport function create_slot(definition, ctx, $$scope, fn) {\n\tif (definition) {\n\t\tconst slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n\t\treturn definition[0](slot_ctx);\n\t}\n}\n\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n\treturn definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\n\nexport function get_slot_changes(definition, $$scope, dirty, fn) {\n\tif (definition[2] && fn) {\n\t\tconst lets = definition[2](fn(dirty));\n\t\tif ($$scope.dirty === undefined) {\n\t\t\treturn lets;\n\t\t}\n\t\tif (typeof lets === 'object') {\n\t\t\tconst merged = [];\n\t\t\tconst len = Math.max($$scope.dirty.length, lets.length);\n\t\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\t\tmerged[i] = $$scope.dirty[i] | lets[i];\n\t\t\t}\n\t\t\treturn merged;\n\t\t}\n\t\treturn $$scope.dirty | lets;\n\t}\n\treturn $$scope.dirty;\n}\n\n/** @returns {void} */\nexport function update_slot_base(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tslot_changes,\n\tget_slot_context_fn\n) {\n\tif (slot_changes) {\n\t\tconst slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n\t\tslot.p(slot_context, slot_changes);\n\t}\n}\n\n/** @returns {void} */\nexport function update_slot(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tdirty,\n\tget_slot_changes_fn,\n\tget_slot_context_fn\n) {\n\tconst slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n\tupdate_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\n\n/** @returns {any[] | -1} */\nexport function get_all_dirty_from_scope($$scope) {\n\tif ($$scope.ctx.length > 32) {\n\t\tconst dirty = [];\n\t\tconst length = $$scope.ctx.length / 32;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdirty[i] = -1;\n\t\t}\n\t\treturn dirty;\n\t}\n\treturn -1;\n}\n\n/** @returns {{}} */\nexport function exclude_internal_props(props) {\n\tconst result = {};\n\tfor (const k in props) if (k[0] !== '$') result[k] = props[k];\n\treturn result;\n}\n\n/** @returns {{}} */\nexport function compute_rest_props(props, keys) {\n\tconst rest = {};\n\tkeys = new Set(keys);\n\tfor (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\n\treturn rest;\n}\n\n/** @returns {{}} */\nexport function compute_slots(slots) {\n\tconst result = {};\n\tfor (const key in slots) {\n\t\tresult[key] = true;\n\t}\n\treturn result;\n}\n\n/** @returns {(this: any, ...args: any[]) => void} */\nexport function once(fn) {\n\tlet ran = false;\n\treturn function (...args) {\n\t\tif (ran) return;\n\t\tran = true;\n\t\tfn.call(this, ...args);\n\t};\n}\n\nexport function null_to_empty(value) {\n\treturn value == null ? '' : value;\n}\n\nexport function set_store_value(store, ret, value) {\n\tstore.set(value);\n\treturn ret;\n}\n\nexport const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport function action_destroyer(action_result) {\n\treturn action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\n/** @param {number | string} value\n * @returns {[number, string]}\n */\nexport function split_css_unit(value) {\n\tconst split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n\treturn split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];\n}\n\nexport const contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n","import {\n\trun_all,\n\tsubscribe,\n\tnoop,\n\tsafe_not_equal,\n\tis_function,\n\tget_store_value\n} from '../internal/index.js';\n\nconst subscriber_queue = [];\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#readable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readable(value, start) {\n\treturn {\n\t\tsubscribe: writable(value, start).subscribe\n\t};\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#writable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Writable<T>}\n */\nexport function writable(value, start = noop) {\n\t/** @type {import('./public.js').Unsubscriber} */\n\tlet stop;\n\t/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */\n\tconst subscribers = new Set();\n\t/** @param {T} new_value\n\t * @returns {void}\n\t */\n\tfunction set(new_value) {\n\t\tif (safe_not_equal(value, new_value)) {\n\t\t\tvalue = new_value;\n\t\t\tif (stop) {\n\t\t\t\t// store is ready\n\t\t\t\tconst run_queue = !subscriber_queue.length;\n\t\t\t\tfor (const subscriber of subscribers) {\n\t\t\t\t\tsubscriber[1]();\n\t\t\t\t\tsubscriber_queue.push(subscriber, value);\n\t\t\t\t}\n\t\t\t\tif (run_queue) {\n\t\t\t\t\tfor (let i = 0; i < subscriber_queue.length; i += 2) {\n\t\t\t\t\t\tsubscriber_queue[i][0](subscriber_queue[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\tsubscriber_queue.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {import('./public.js').Updater<T>} fn\n\t * @returns {void}\n\t */\n\tfunction update(fn) {\n\t\tset(fn(value));\n\t}\n\n\t/**\n\t * @param {import('./public.js').Subscriber<T>} run\n\t * @param {import('./private.js').Invalidator<T>} [invalidate]\n\t * @returns {import('./public.js').Unsubscriber}\n\t */\n\tfunction subscribe(run, invalidate = noop) {\n\t\t/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */\n\t\tconst subscriber = [run, invalidate];\n\t\tsubscribers.add(subscriber);\n\t\tif (subscribers.size === 1) {\n\t\t\tstop = start(set, update) || noop;\n\t\t}\n\t\trun(value);\n\t\treturn () => {\n\t\t\tsubscribers.delete(subscriber);\n\t\t\tif (subscribers.size === 0 && stop) {\n\t\t\t\tstop();\n\t\t\t\tstop = null;\n\t\t\t}\n\t\t};\n\t}\n\treturn { set, update, subscribe };\n}\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * @template {import('./private.js').Stores} S\n * @template T\n * @param {S} stores\n * @param {Function} fn\n * @param {T} [initial_value]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function derived(stores, fn, initial_value) {\n\tconst single = !Array.isArray(stores);\n\t/** @type {Array<import('./public.js').Readable<any>>} */\n\tconst stores_array = single ? [stores] : stores;\n\tif (!stores_array.every(Boolean)) {\n\t\tthrow new Error('derived() expects stores as input, got a falsy value');\n\t}\n\tconst auto = fn.length < 2;\n\treturn readable(initial_value, (set, update) => {\n\t\tlet started = false;\n\t\tconst values = [];\n\t\tlet pending = 0;\n\t\tlet cleanup = noop;\n\t\tconst sync = () => {\n\t\t\tif (pending) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcleanup();\n\t\t\tconst result = fn(single ? values[0] : values, set, update);\n\t\t\tif (auto) {\n\t\t\t\tset(result);\n\t\t\t} else {\n\t\t\t\tcleanup = is_function(result) ? result : noop;\n\t\t\t}\n\t\t};\n\t\tconst unsubscribers = stores_array.map((store, i) =>\n\t\t\tsubscribe(\n\t\t\t\tstore,\n\t\t\t\t(value) => {\n\t\t\t\t\tvalues[i] = value;\n\t\t\t\t\tpending &= ~(1 << i);\n\t\t\t\t\tif (started) {\n\t\t\t\t\t\tsync();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tpending |= 1 << i;\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\t\tstarted = true;\n\t\tsync();\n\t\treturn function stop() {\n\t\t\trun_all(unsubscribers);\n\t\t\tcleanup();\n\t\t\t// We need to set this to false because callbacks can still happen despite having unsubscribed:\n\t\t\t// Callbacks might already be placed in the queue which doesn't know it should no longer\n\t\t\t// invoke this derived store.\n\t\t\tstarted = false;\n\t\t};\n\t});\n}\n\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * https://svelte.dev/docs/svelte-store#readonly\n * @template T\n * @param {import('./public.js').Readable<T>} store  - store to make readonly\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readonly(store) {\n\treturn {\n\t\tsubscribe: store.subscribe.bind(store)\n\t};\n}\n\nexport { get_store_value as get };\n","import { writable } from 'svelte/store';\nimport type { Annotation } from '../model';\nimport type { Store } from './Store';\n\nexport type HoverState<T extends Annotation> = ReturnType<typeof createHoverState<T>>;\n\nexport const createHoverState = <T extends Annotation>(store: Store<T>) => {\n\n  const { subscribe, set } = writable<string | undefined>();\n\n  let currentHover: string | undefined;\n\n  subscribe(updated => currentHover = updated);\n\n  // Track store delete and update events\n  store.observe(( { changes }) => {    \n    if (currentHover) {\n      const isDeleted = (changes.deleted || []).some(a => a.id === currentHover);\n      if (isDeleted)\n        set(undefined);\n    \n      const updated = (changes.updated || []).find(({ oldValue }) => oldValue.id === currentHover);\n      if (updated)\n        set(updated.newValue.id);\n    }\n  });\n\n  return { \n    get current() { return currentHover },\n    subscribe, \n    set \n  };\n\n}\n","import { writable } from 'svelte/store';\nimport type {  Annotation } from '../model';\nimport type { Store } from './Store';\n   \nexport type Selection = {\n\n  selected: { id: string, editable?: boolean }[],\n\n  pointerEvent?: PointerEvent;\n\n}\n\nexport type SelectionState<T extends Annotation> = ReturnType<typeof createSelectionState<T>>;\n\nexport enum PointerSelectAction {\n\n  EDIT = 'EDIT', // Make annotation target(s) editable on pointer select\n  \n  SELECT = 'SELECT',  // Just select, but don't make editable\n\n  NONE = 'NONE' // Click won't select - annotation is completely inert\n\n}\n\nconst EMPTY: Selection = { selected: [] };\n\nexport const createSelectionState = <T extends Annotation>(\n  store: Store<T>,\n  selectAction: PointerSelectAction | ((a: T) => PointerSelectAction) = PointerSelectAction.EDIT\n) => {\n  const { subscribe, set } = writable<Selection>(EMPTY);\n\n  let currentSelection: Selection = EMPTY;\n\n  subscribe(updated => currentSelection = updated);\n\n  const clear = () => set(EMPTY);\n\n  const isEmpty = () => currentSelection.selected?.length === 0;\n\n  const isSelected = (annotationOrId: T | string) => {\n    if (currentSelection.selected.length === 0)\n      return false;\n\n    const id = typeof annotationOrId === 'string' ? annotationOrId : annotationOrId.id;\n    return currentSelection.selected.some(i => i.id === id);\n  }\n\n  // TODO enable CTRL select\n  const clickSelect = (id: string, pointerEvent: PointerEvent) => {\n    const annotation = store.getAnnotation(id);\n    if (annotation) {\n      const action = onPointerSelect(annotation, selectAction);\n      if (action === PointerSelectAction.EDIT)\n        set({ selected: [{ id, editable: true }], pointerEvent }); \n      else if (action === PointerSelectAction.SELECT)\n        set({ selected: [{ id }], pointerEvent }); \n      else\n        set({ selected: [], pointerEvent });\n    } else {\n      console.warn('Invalid selection: ' + id);\n    }\n  }\n\n  const setSelected = (idOrIds: string | string[], editable: boolean = true) => {\n    const ids = Array.isArray(idOrIds) ? idOrIds : [idOrIds];\n\n    // Remove invalid\n    const annotations = \n      ids.map(id => store.getAnnotation(id)!).filter(Boolean); \n\n    set({ selected: annotations.map(({ id }) => ({ id, editable })) });\n    \n    if (annotations.length !== ids.length)\n      console.warn('Invalid selection', idOrIds);\n  }\n\n  const removeFromSelection = (ids: string[]) => {\n    if (currentSelection.selected.length === 0)\n      return false;\n\n    const { selected } = currentSelection;\n\n    // Checks which of the given annotations are actually in the selection\n    const toRemove = selected.filter(({ id  }) => ids.includes(id))\n\n    if (toRemove.length > 0)\n      set({ selected: selected.filter(({ id }) => !ids.includes(id)) });\n  }\n\n  // Track store delete and update events\n  store.observe(({ changes }) =>\n    removeFromSelection((changes.deleted || []).map(a => a.id)));\n\n  return { \n    clear, \n    clickSelect, \n    get selected() { return currentSelection ? [...currentSelection.selected ] : null},\n    get pointerEvent() { return currentSelection ? currentSelection.pointerEvent : null },\n    isEmpty, \n    isSelected, \n    setSelected, \n    subscribe \n  };\n\n}\n\nexport const onPointerSelect = <T extends Annotation>(\n  annotation: T, \n  action?: PointerSelectAction | ((a: T) => PointerSelectAction)\n): PointerSelectAction => (typeof action === 'function') ?\n    (action(annotation) || PointerSelectAction.EDIT) : \n    (action || PointerSelectAction.EDIT);\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","import { v4 as uuidv4 } from 'uuid';\nimport type { Annotation, AnnotationBody } from '../model/Annotation';\nimport type {  User } from '../model/User';\n/**\n * Returns all users listed as creators or updaters in any parts of this\n * annotation.\n */\nexport const getContributors = (annotation: Annotation): User[] => {\n  const { creator, updatedBy } = annotation.target;\n\n  const bodyCollaborators = annotation.bodies.reduce((users, body) =>  (\n    [...users, body.creator, body.updatedBy].filter(Boolean) as User[]\n  ), [] as User[]);\n\n  return [\n    creator,\n    updatedBy,\n    ...bodyCollaborators\n  ].filter(u => u) as User[] // Remove undefined\n}\n\nexport const createBody = (\n  annotation: Annotation, \n  payload: { [key: string]: any },\n  created?: Date,\n  creator?: User\n): AnnotationBody => ({\n  id: uuidv4(),\n  annotation: annotation.id,\n  created: created || new Date(),\n  creator,\n  ...payload\n});","import { dequal } from 'dequal/lite';\nimport type { Update } from '../state/StoreObserver';\nimport type { Annotation } from '../model/Annotation';\n\nconst getAddedBodies = (oldValue: Annotation, newValue: Annotation) => {\n  const oldBodyIds = new Set(oldValue.bodies.map(b => b.id));\n  return newValue.bodies.filter(b => !oldBodyIds.has(b.id));\n}\n\nconst getRemovedBodies = (oldValue: Annotation, newValue: Annotation) => {\n  const newBodyIds = new Set(newValue.bodies.map(b => b.id));\n  return oldValue.bodies.filter(b => !newBodyIds.has(b.id));\n}\n\nconst getChangedBodies = (oldValue: Annotation, newValue: Annotation) => \n  newValue.bodies\n    .map(newBody => {\n      const oldBody = oldValue.bodies.find(b => b.id === newBody.id);\n      return { newBody, oldBody: oldBody && !dequal(oldBody, newBody) ? oldBody : undefined }\n    })\n    .filter(({ oldBody }) => oldBody)\n    .map(({ oldBody, newBody }) => ({ oldBody: oldBody!, newBody }));\n\nconst hasTargetChanged = (oldValue: Annotation, newValue: Annotation) => \n  !dequal(oldValue.target, newValue.target);\n\nexport const diffAnnotations = <T extends Annotation = Annotation>(oldValue: T, newValue: T): Update<T> => {\n  const bodiesCreated = getAddedBodies(oldValue, newValue);\n  const bodiesDeleted = getRemovedBodies(oldValue, newValue);\n  const bodiesUpdated = getChangedBodies(oldValue, newValue);\n\n  return {\n    oldValue, \n    newValue,\n    bodiesCreated: bodiesCreated.length > 0 ? bodiesCreated : undefined,\n    bodiesDeleted: bodiesDeleted.length > 0 ? bodiesDeleted : undefined,\n    bodiesUpdated: bodiesUpdated.length > 0 ? bodiesUpdated : undefined,\n    targetUpdated: hasTargetChanged(oldValue, newValue) ? { oldTarget: oldValue.target, newTarget: newValue.target } : undefined\n  }\n}","import type { Annotation, AnnotationBody, AnnotationTarget } from '../model/Annotation';\nimport { diffAnnotations } from '../utils';\n\n/** Interface for listening to changes in the annotation store **/\nexport interface StoreObserver<T extends Annotation> { \n\n  onChange: { (event: StoreChangeEvent<T>): void };\n\n  options: StoreObserveOptions;\n\n}\n\n/** A change event fired when the store state changes **/\nexport interface StoreChangeEvent<T extends Annotation> {\n\n  origin: Origin;\n\n  changes: ChangeSet<T>;\n\n  state: T[];\n\n}\n\nexport interface ChangeSet<T extends Annotation> {\n\n  created?: T[];\n\n  deleted?: T[];\n\n  updated?: Update<T>[];\n\n}\n\nexport interface Update<T extends Annotation> {\n\n  oldValue: T;\n\n  newValue: T;\n\n  bodiesCreated?: AnnotationBody[];\n\n  bodiesDeleted?: AnnotationBody[];\n\n  bodiesUpdated?: Array<{ oldBody: AnnotationBody, newBody: AnnotationBody }>;\n\n  targetUpdated?: { oldTarget: AnnotationTarget, newTarget: AnnotationTarget};\n\n}\n\n/** Options to control which events the observer wants to get notified about **/\nexport interface StoreObserveOptions {\n\n  // Observe changes on targets, bodies or both?\n  ignore?: Ignore;\n\n  // Observe changes on one more specific annotations\n  annotations?: string | string[];\n\n  // Observer changes only for a specific origin\n  origin?: Origin\n\n}\n\n/** Allows the observer to ignore certain event types **/\nexport enum Ignore { \n\n  // Don't notify this observer for changes that involve bodies only\n  BODY_ONLY = 'BODY_ONLY',\n\n  // Don't notify for changes on targets only\n  TARGET_ONLY = 'TARGET_ONLY'\n\n}\n\n/** Allows the observer to listen only for events that originated locally or from a remote source **/\nexport enum Origin { \n  \n  LOCAL = 'LOCAL', \n  \n  REMOTE = 'REMOTE' \n\n}\n\n/** Tests if this observer should be notified about this event **/\nexport const shouldNotify = <T extends Annotation>(observer: StoreObserver<T>, event: StoreChangeEvent<T>) => {\n  const { changes, origin } = event;\n\n  const isRelevantOrigin = \n    !observer.options.origin || observer.options.origin === origin;\n\n  if (!isRelevantOrigin)\n    return false;\n\n  if (observer.options.ignore) {\n    const { ignore } = observer.options;\n\n    // Shorthand\n    const has = (arg: any[] | undefined) => arg && arg.length > 0;\n\n    const hasAnnotationChanges =\n      has(changes.created) || has(changes.deleted);\n\n    if (!hasAnnotationChanges) {\n      const hasBodyChanges =\n        changes.updated?.some(u => has(u.bodiesCreated) || has(u.bodiesDeleted) || has(u.bodiesUpdated));\n    \n      const hasTargetChanges = \n        changes.updated?.some(u => u.targetUpdated);\n\n      if (ignore === Ignore.BODY_ONLY && hasBodyChanges && !hasTargetChanges)\n        return false;\n\n      if (ignore === Ignore.TARGET_ONLY && hasTargetChanges && !hasBodyChanges)\n        return false;\n    }\n  }\n\n  if (observer.options.annotations) {\n    // This observer has a filter set on specific annotations - check affected\n    const affectedAnnotations = new Set([\n      ...(changes.created || []).map(a => a.id),\n      ...(changes.deleted || []).map(a => a.id),\n      ...(changes.updated || []).map(({ oldValue }) => oldValue.id)\n    ]);\n\n    const observed = Array.isArray(observer.options.annotations) ?\n      observer.options.annotations : [ observer.options.annotations ];\n\n    return Boolean(observed.find(id => affectedAnnotations.has(id)));\n  } else {\n    return true;\n  }\n\n}\n\nexport const mergeChanges = <T extends Annotation>(changes: ChangeSet<T>, toMerge: ChangeSet<T>) => {\n  const previouslyCreatedIds = new Set((changes.created || []).map(a => a.id));\n  const previouslyUpdatedIds = new Set((changes.updated || []).map(({ newValue })=> newValue.id));\n\n  const createdIds = new Set((toMerge.created || []).map(a => a.id));\n  const deletedIds = new Set((toMerge.deleted || []).map(a => a.id));\n  const updatedIds = new Set((toMerge.updated || []).map(({ oldValue }) => oldValue.id));\n\n  // Updates that will be merged into create or previous update events\n  const mergeableUpdates = new Set((toMerge.updated ||Â [])\n    .filter(({ oldValue }) => previouslyCreatedIds.has(oldValue.id) || previouslyUpdatedIds.has(oldValue.id))\n    .map(({ oldValue }) => oldValue.id ));\n\n  // * created *\n  // - drop created that were then deleted\n  // - merge any updates on created\n  // - append newly created\n  const created = [\n    ...(changes.created || [])\n      .filter(a => !deletedIds.has(a.id))\n      .map(a => updatedIds.has(a.id) \n        ? toMerge.updated!.find(({ oldValue }) => oldValue.id === a.id)!.newValue\n        : a),\n    ...(toMerge.created || [])\n  ];\n\n  // * deleted *\n  // - drop deleted that were later re-created (redo action!)\n  // - append newly deleted, but remove any that delete annotations \n  //   that were created in the same round\n  const deleted = [\n    ...(changes.deleted || [])\n      .filter(a => !createdIds.has(a.id)),\n    ...(toMerge.deleted || []) \n      .filter(a => !previouslyCreatedIds.has(a.id))\n  ] \n\n  // * updated *\n  // - drop updates on deleted annotations\n  // - merge any updates that override previous ones\n  // - append new updates, but remove any that were merged\n  const updated = [\n    ...(changes.updated || [])\n      .filter(({ newValue }) => !deletedIds.has(newValue.id))\n      .map(update => {\n        const { oldValue, newValue } = update;\n        if (updatedIds.has(newValue.id)) {\n          const updated = toMerge.updated!.find(u => u.oldValue.id === newValue.id)!.newValue;\n          return diffAnnotations(oldValue, updated);\n        } else {\n          return update;\n        }\n      }),\n    ...(toMerge.updated || []).filter(({ oldValue }) => !mergeableUpdates.has(oldValue.id))\n  ]\n\n  return { created, deleted, updated };\n}","import type { Annotation } from '../model';\nimport { diffAnnotations } from '../utils';\nimport { Origin, shouldNotify, type Update, type ChangeSet } from './StoreObserver';\nimport type { StoreObserver, StoreChangeEvent, StoreObserveOptions } from './StoreObserver';\n\n// Shorthand\ntype AnnotationBodyIdentifier = { id: string, annotation: string }; \n\nexport type Store<T extends Annotation> = ReturnType<typeof createStore<T>>;\n\nconst isAnnotation = <T extends Annotation>(arg: any): arg is T => arg.id !== undefined;\n\nexport const createStore = <T extends Annotation>() => {\n\n  const annotationIndex = new Map<string, T>();\n\n  const bodyIndex = new Map<string, string>();\n\n  const observers: StoreObserver<T>[] = [];\n\n  const observe = (onChange: { (event: StoreChangeEvent<T>): void }, options: StoreObserveOptions = {}) =>\n    observers.push({ onChange, options });\n\n  const unobserve = (onChange: { (event: StoreChangeEvent<T>): void }) => {\n    const idx = observers.findIndex(observer => observer.onChange == onChange);\n    if (idx > -1)\n      observers.splice(idx, 1);\n  }\n\n  const emit = (origin: Origin, changes: ChangeSet<T>) => {\n    const event: StoreChangeEvent<T> = {\n      origin,\n      changes: {\n        created: changes.created || [],\n        updated: changes.updated || [],\n        deleted: changes.deleted || []\n      },\n      state: [...annotationIndex.values()]\n    };\n\n    observers.forEach(observer => {\n      if (shouldNotify(observer, event))\n        observer.onChange(event);\n    });\n  }\n\n  const addAnnotation = (annotation: T, origin = Origin.LOCAL) => {\n    const existing = annotationIndex.get(annotation.id);\n\n    if (existing) {\n      throw Error(`Cannot add annotation ${annotation.id} - exists already`);\n    } else {\n      annotationIndex.set(annotation.id, annotation);\n\n      annotation.bodies.forEach(b => bodyIndex.set(b.id, annotation.id));\n      emit(origin, { created: [annotation] });\n    }\n  }\n\n  const updateOneAnnotation = (arg1: string | T, arg2?: T | Origin) => {\n    const updated: T = typeof arg1 === 'string' ? arg2 as T : arg1;\n\n    const oldId: string = typeof arg1 === 'string' ? arg1 : arg1.id;\n    const oldValue = annotationIndex.get(oldId);\n\n    if (oldValue) {\n      const update: Update<T> = diffAnnotations(oldValue, updated);\n\n      if (oldId === updated.id) {\n        annotationIndex.set(oldId, updated);\n      } else {\n        annotationIndex.delete(oldId);\n        annotationIndex.set(updated.id, updated);\n      }\n\n      oldValue.bodies.forEach(b => bodyIndex.delete(b.id));\n      updated.bodies.forEach(b => bodyIndex.set(b.id, updated.id));\n\n      return update;\n    } else {\n      console.warn(`Cannot update annotation ${oldId} - does not exist`);\n    }\n  }\n  \n  const updateAnnotation = (arg1: string | T, arg2: T | Origin = Origin.LOCAL, arg3 = Origin.LOCAL) => {\n    const origin: Origin = isAnnotation(arg2) ? arg3 : arg2;\n\n    const update = updateOneAnnotation(arg1, arg2);\n    if (update)\n      emit(origin, { updated: [update] })\n  }\n\n  const bulkUpdateAnnotation = (annotations: T[], origin = Origin.LOCAL) => {\n    const updated = annotations.reduce((updated, annotation) => {\n      const u = updateOneAnnotation(annotation);\n      return u ? [...updated, u] : updated;\n    }, [] as Update<T>[]);\n\n    if (updated.length > 0)\n      emit(origin, { updated });\n  }\n\n  const addBody = (body: T['bodies'][number], origin = Origin.LOCAL) => {\n    const oldValue = annotationIndex.get(body.annotation);\n    if (oldValue) {\n      const newValue = { \n        ...oldValue,\n        bodies: [ ...oldValue.bodies, body ]\n      };\n\n      annotationIndex.set(oldValue.id, newValue);\n\n      bodyIndex.set(body.id, newValue.id);\n\n      const update: Update<T> = {\n        oldValue, newValue, bodiesCreated: [ body ]\n      };\n\n      emit(origin, { updated: [update] });\n    } else {\n      console.warn(`Attempt to add body to missing annotation: ${body.annotation}`);\n    }\n  }\n\n  const all = () => [...annotationIndex.values()];\n\n  const clear = (origin = Origin.LOCAL) => { \n    const all = [...annotationIndex.values()];\n\n    annotationIndex.clear();\n    bodyIndex.clear();\n\n    emit(origin, { deleted: all });\n  }\n\n  const bulkAddAnnotation = (annotations: T[], replace = true, origin = Origin.LOCAL) => {\n    if (replace) {\n      // Delete existing first\n      const deleted = [...annotationIndex.values()];\n      annotationIndex.clear();\n      bodyIndex.clear();\n\n      annotations.forEach(annotation => {\n        annotationIndex.set(annotation.id, annotation);\n        annotation.bodies.forEach(b => bodyIndex.set(b.id, annotation.id));\n      });\n\n      emit(origin, { created: annotations, deleted });\n    } else {\n      // Don't allow overwriting of existing annotations\n      const existing = annotations.reduce((all, next) => {\n        const existing = annotationIndex.get(next.id);\n        return existing ? [...all, existing ] : all;\n      }, [] as T[]);\n\n      if (existing.length > 0)\n        throw Error(`Bulk insert would overwrite the following annotations: ${existing.map(a => a.id).join(', ')}`);\n\n      annotations.forEach(annotation => {\n        annotationIndex.set(annotation.id, annotation);\n        annotation.bodies.forEach(b => bodyIndex.set(b.id, annotation.id));\n      });\n\n      emit(origin, { created: annotations });\n    }\n  }\n\n  const deleteOneAnnotation = (annotationOrId: T | string) => {\n    const id = typeof annotationOrId === 'string' ? annotationOrId : annotationOrId.id;\n\n    const existing = annotationIndex.get(id);\n    if (existing) {\n      annotationIndex.delete(id);\n      existing.bodies.forEach(b => bodyIndex.delete(b.id));\n      return existing;\n    } else {\n      console.warn(`Attempt to delete missing annotation: ${id}`);\n    }\n  }\n\n  const deleteAnnotation = (annotationOrId: T | string, origin = Origin.LOCAL) => {\n    const deleted = deleteOneAnnotation(annotationOrId);\n    if (deleted)\n      emit(origin, { deleted: [ deleted  ]});\n  }\n\n  const bulkDeleteAnnotation = (annotationsOrIds: (T | string)[], origin = Origin.LOCAL) => {\n    const deleted = annotationsOrIds.reduce((deleted, arg) => {\n      const existing = deleteOneAnnotation(arg);\n      return existing ? [...deleted, existing] : deleted;\n    }, [] as T[]);\n\n    if (deleted.length > 0)\n      emit(origin, { deleted });\n  }\n\n  const deleteOneBody = (body: AnnotationBodyIdentifier) => {\n    const oldAnnotation = annotationIndex.get(body.annotation);\n\n    if (oldAnnotation) {\n      const oldBody = oldAnnotation.bodies.find(b => b.id === body.id);\n\n      if (oldBody) {\n        bodyIndex.delete(oldBody.id);\n\n        const newAnnotation = {\n          ...oldAnnotation,\n          bodies: oldAnnotation.bodies.filter(b => b.id !== body.id)\n        };\n\n        annotationIndex.set(oldAnnotation.id, newAnnotation);\n\n        const update: Update<T> = {\n          oldValue: oldAnnotation, newValue: newAnnotation, bodiesDeleted: [oldBody]\n        };\n\n        return update;\n      } else {\n        console.warn(`Attempt to delete missing body ${body.id} from annotation ${body.annotation}`);\n      }\n    } else {\n      console.warn(`Attempt to delete body from missing annotation ${body.annotation}`);\n    }\n  }\n \n  const deleteBody = (body: AnnotationBodyIdentifier, origin = Origin.LOCAL) => {\n    const updated = deleteOneBody(body);\n    if (updated)\n      emit(origin, { updated: [ updated  ]});\n  }\n\n  const bulkDeleteBodies = (bodies: AnnotationBodyIdentifier[], origin = Origin.LOCAL) => {\n    const updated = bodies\n      .map(b => deleteOneBody(b)!)\n      .filter(Boolean);\n\n    if (updated.length > 0)\n      emit(origin, { updated });\n  }\n\n  const getAnnotation = (id: string): T | undefined => {\n    const a = annotationIndex.get(id);\n    return a ? {...a} : undefined;\n  }\n\n  const getBody = (id: string): T['bodies'][number] | undefined => {\n    const annotationId = bodyIndex.get(id);\n    if (annotationId) {\n      const annotation = getAnnotation(annotationId);\n      const body = annotation!.bodies.find(b => b.id === id);\n      if (body) {\n        return body;\n      } else {\n        console.error(`Store integrity error: body ${id} in index, but not in annotation`);\n      }\n    } else {\n      console.warn(`Attempt to retrieve missing body: ${id}`);\n    }\n  }\n\n  const updateOneBody = (oldBodyId: AnnotationBodyIdentifier, newBody: T['bodies'][number]) => {\n    if (oldBodyId.annotation !== newBody.annotation)\n      throw 'Annotation integrity violation: annotation ID must be the same when updating bodies';\n\n    const oldAnnotation = annotationIndex.get(oldBodyId.annotation);\n    if (oldAnnotation) {\n      const oldBody = oldAnnotation.bodies.find(b => b.id === oldBodyId.id)!;\n\n      const newAnnotation = { \n        ...oldAnnotation,\n        bodies: oldAnnotation.bodies.map(b => b.id === oldBody.id ? newBody : b)\n      };\n\n      annotationIndex.set(oldAnnotation.id, newAnnotation);\n\n      if (oldBody.id !== newBody.id) {\n        bodyIndex.delete(oldBody.id);\n        bodyIndex.set(newBody.id, newAnnotation.id);\n      }\n\n      return {\n        oldValue: oldAnnotation, \n        newValue: newAnnotation,\n        bodiesUpdated: [{ oldBody, newBody }]\n      }\n    } else {\n      console.warn(`Attempt to add body to missing annotation ${oldBodyId.annotation}`);\n    }\n  }\n\n  const updateBody = (oldBodyId: AnnotationBodyIdentifier, newBody: T['bodies'][number], origin = Origin.LOCAL) => {\n    const update = updateOneBody(oldBodyId, newBody);\n    if (update)\n      emit(origin, { updated: [ update ]} );\n  }\n\n  const bulkUpdateBodies = (bodies: Array<T['bodies'][number]>, origin = Origin.LOCAL) => {\n    const updated = bodies\n      .map(b => updateOneBody({ id: b.id, annotation: b.annotation }, b)!)\n      .filter(Boolean);\n\n    emit(origin, { updated });\n  }\n\n  const updateOneTarget = (target: T['target']): Update<T> | undefined => {\n    const oldValue = annotationIndex.get(target.annotation);\n    \n    if (oldValue) {\n      const newValue = { \n        ...oldValue, \n        target: {\n          ...oldValue.target,\n          ...target \n        }\n      };\n\n      annotationIndex.set(oldValue.id, newValue);\n\n      return {\n        oldValue, newValue, targetUpdated: { \n          oldTarget: oldValue.target,\n          newTarget: target\n        }\n      };\n    } else {\n      console.warn(`Attempt to update target on missing annotation: ${target.annotation}`);\n    }\n  }\n\n  const updateTarget = (target: T['target'], origin = Origin.LOCAL) => {\n    const update = updateOneTarget(target);\n    if (update)\n      emit(origin, { updated: [ update ]} );\n  }\n\n  const bulkUpdateTargets = (targets: Array<T['target']>, origin = Origin.LOCAL) => {\n    const updated = \n      targets.map(t => updateOneTarget(t)!).filter(Boolean);\n    if (updated.length > 0)\n      emit(origin, { updated });\n  }\n\n\treturn {\n    addAnnotation,\n    addBody,\n    all,\n    bulkAddAnnotation,\n    bulkDeleteAnnotation,\n    bulkDeleteBodies,\n    bulkUpdateAnnotation,\n    bulkUpdateBodies,\n    bulkUpdateTargets,\n    clear,\n    deleteAnnotation,\n    deleteBody,\n    getAnnotation,\n    getBody,\n    observe,\n    unobserve,\n    updateAnnotation,\n    updateBody,\n    updateTarget\n\t};\n\n}\n","import type { Annotation, Annotator, AnnotatorState } from '../model';\nimport type { Store } from './Store';\nimport type { StoreChangeEvent } from './StoreObserver';\n\ntype Subscriber<T extends Annotation> = (annotation: T[]) => void; \n\nexport interface SvelteStore<T extends Annotation> extends Store<T> {\n\n  subscribe(onChange: Subscriber<T>): void;\n\n}\n\nexport interface SvelteAnnotatorState<T extends Annotation> extends AnnotatorState<T> {\n\n  store: SvelteStore<T>\n\n}\n\nexport interface SvelteAnnotator<T extends Annotation> extends Annotator<T> {\n\n  state: SvelteAnnotatorState<T>\n\n}\n\n/** \n * A simple wrapper around the event-based store implementation\n * that adds a Svelte shim, for use with the reactive '$' notation.\n * Other frameworks might not actually need this. But it's pretty\n * convenient for everyone using Svelte, as well as for the\n * basic (Svelte-based) Annotorious standard implementation.\n */\nexport const toSvelteStore = <T extends Annotation>(store: Store<T>): SvelteStore<T> => {\n\n  const subscribe = (onChange: Subscriber<T>) => {\n\n    // Register a store observer on behalf of the subscriber\n    const shim = (event: StoreChangeEvent<T>) => onChange(event.state);\n    store.observe(shim);\n\n    // Immediately call the subscriber function with the\n    // current store value, according to the Svelte contract.\n    // https://stackoverflow.com/questions/68220955/how-does-svelte-unsubscribe-actually-work\n    onChange(store.all());\n\n    // Return the unsubscribe function\n    return () => store.unobserve(shim);\n  }\n\n  return {\n    ...store,\n    subscribe\n  }\n\n}","export let createNanoEvents = () => ({\n  emit(event, ...args) {\n    for (\n      let i = 0,\n        callbacks = this.events[event] || [],\n        length = callbacks.length;\n      i < length;\n      i++\n    ) {\n      callbacks[i](...args)\n    }\n  },\n  events: {},\n  on(event, cb) {\n    ;(this.events[event] ||= []).push(cb)\n    return () => {\n      this.events[event] = this.events[event]?.filter(i => cb !== i)\n    }\n  }\n})\n","import { createNanoEvents, type Unsubscribe } from 'nanoevents';\nimport type { Annotation } from '../model';\nimport type { Store } from './Store';\nimport { Origin } from './StoreObserver';\nimport { mergeChanges, type ChangeSet, type StoreChangeEvent, type Update } from './StoreObserver';\n\n// Duration with fast successive changes get merged \n// with the last event in the stack, rather than getting stacked\n// as a new undo/redo step.\nconst DEBOUNCE = 250;\n\nexport interface UndoStack <T extends Annotation> {\n\n  canRedo(): boolean;\n\n  canUndo(): boolean;\n\n  destroy(): void;\n\n  on<E extends keyof UndoStackEvents<T>>(event: E, callback: UndoStackEvents<T>[E]): Unsubscribe;\n\n  undo(): void;\n\n  redo(): void;\n\n}\n\nexport interface UndoStackEvents <T extends Annotation> {\n\n  redo(change: ChangeSet<T>): void;\n\n  undo(change: ChangeSet<T>): void;\n\n}\n\nexport const createUndoStack = <T extends Annotation>(store: Store<T>): UndoStack<T> => {\n\n  const emitter = createNanoEvents<UndoStackEvents<T>>();\n\n  const changeStack: ChangeSet<T>[] = [];\n\n  let pointer = -1;\n\n  let muteEvents = false;\n\n  let lastEvent = 0;\n\n  const onChange = (event: StoreChangeEvent<T>) => {\n    if (!muteEvents) {\n      const { changes } = event;\n\n      const now = performance.now();\n\n      if (now - lastEvent > DEBOUNCE) {\n        // Put this change on the stack...\n        changeStack.splice(pointer + 1);\n        changeStack.push(changes);\n\n        // ...and update the pointer\n        pointer = changeStack.length - 1;\n      } else {\n        // Merge this change with the last in the stack\n        const last = changeStack.length - 1;\n        changeStack[last] = mergeChanges(changeStack[last], changes);\n      }\n\n      lastEvent = now;\n    }\n\n    muteEvents = false;\n  }\n\n  store.observe(onChange, { origin: Origin.LOCAL });\n\n  const undoCreated = (created?: T[]) =>\n    created && created.length > 0 && store.bulkDeleteAnnotation(created);\n\n  const redoCreated = (created?: T[]) =>\n    created && created.length > 0 && store.bulkAddAnnotation(created, false);\n\n  const undoUpdated = (updated?: Update<T>[]) =>\n    updated && updated.length > 0 && store.bulkUpdateAnnotation(updated.map(({ oldValue }) => oldValue));\n      \n  const redoUpdated = (updated?: Update<T>[]) =>\n    updated && updated.length > 0 && store.bulkUpdateAnnotation(updated.map(({ newValue }) => newValue));\n\n  const undoDeleted = (deleted?: T[]) => \n    deleted && deleted.length > 0 && store.bulkAddAnnotation(deleted, false);\n\n  const redoDeleted = (deleted?: T[]) =>\n    deleted && deleted.length > 0 && store.bulkDeleteAnnotation(deleted);\n\n  const undo = () => {\n    if (pointer > -1) {\n      muteEvents = true;\n\n      const { created, updated, deleted } = changeStack[pointer];\n\n      undoCreated(created);\n      undoUpdated(updated);\n      undoDeleted(deleted);\n\n      emitter.emit('undo', changeStack[pointer]);\n\n      pointer -= 1;\n    }\n  }\n\n  const canUndo = () => pointer > -1;\n\n  const redo = () => {\n    if (changeStack.length - 1 > pointer) {\n      muteEvents = true;\n\n      const { created, updated, deleted } = changeStack[pointer + 1];\n\n      redoCreated(created);\n      redoUpdated(updated);\n      redoDeleted(deleted);\n\n      emitter.emit('redo', changeStack[pointer + 1]);\n\n      pointer += 1;\n    }\n  }\n\n  const canRedo = () => changeStack.length - 1 > pointer;\n\n  const destroy = () => store.unobserve(onChange);\n\n  const on = <E extends keyof UndoStackEvents<T>>(event: E, callback: UndoStackEvents<T>[E]) => \n    emitter.on(event, callback);\n\n  return {\n    canRedo,\n    canUndo,\n    destroy,\n    on,\n    redo,\n    undo\n  }\n\n}","import { writable } from 'svelte/store';\n\nexport type ViewportState = ReturnType<typeof createViewportState>;\n\nexport const createViewportState = () => {\n\n  const { subscribe, set } = writable<string[]>([]);\n\n  return { \n    subscribe, \n    set\n  };\n\n}\n","import { dequal } from 'dequal/lite';\nimport type { Annotation, AnnotatorState, FormatAdapter } from '../model';\nimport { Origin, type ChangeSet, type UndoStack } from '../state';\nimport type { LifecycleEvents } from './LifecycleEvents';\n\nexport type Lifecycle<I extends Annotation, E extends unknown> = \n  ReturnType<typeof createLifecyleObserver<I, E>>;\n\nexport const createLifecyleObserver = <I extends Annotation, E extends unknown>(\n  state: AnnotatorState<I>,\n  undoStack: UndoStack<I>,\n  adapter?: FormatAdapter<I, E>,\n  autoSave?: boolean\n) => {\n  const { store, selection, hover, viewport } = state;\n\n  const observers: Map<keyof LifecycleEvents, Function[]> = new Map();\n\n  // The currently selected annotations, in the state when they were selected \n  let initialSelection: I[] = [];\n\n  let currentHover: string | undefined;\n\n  let idleTimeout: ReturnType<typeof setTimeout>;\n\n  const on = <T extends keyof LifecycleEvents>(event: T, callback: LifecycleEvents<E>[T]) => {\n    if (observers.has(event)) {\n      observers.get(event)!.push(callback);\n    } else {\n      observers.set(event, [callback]);\n    }\n  }\n\n  const off = <T extends keyof LifecycleEvents<E>>(event: T, callback: LifecycleEvents<E>[T]) => {\n    const callbacks = observers.get(event);\n    if (callbacks) {\n      const idx = callbacks.indexOf(callback);\n      if (idx > 0)\n        callbacks.splice(callbacks.indexOf(callback), 1);\n    }\n  }\n\n  const emit = (event: keyof LifecycleEvents<E>, arg0: I | I[], arg1?: I | PointerEvent) => {\n    if (observers.has(event)) {\n      setTimeout(() => {\n        observers.get(event)!.forEach(callback => { \n          if (adapter) {\n            const serialized0 = Array.isArray(arg0) ? \n              arg0.map(a => adapter.serialize(a)) : adapter.serialize(arg0);\n            \n            const serialized1: E | PointerEvent | undefined =\n              arg1 ? arg1 instanceof PointerEvent ? arg1 : adapter.serialize(arg1) : undefined;\n\n            callback(serialized0 as E & E[], serialized1); \n          } else {\n            callback(arg0 as E & E[], arg1 as unknown as E);  \n          }\n        });\n      }, 1);\n    }\n  }\n\n  const onIdleUpdate = () => {\n    const { selected } = selection;\n\n    // User idle after activity - fire update events for selected\n    // annotations that changed\n    const updatedSelected = (selected || []).map(({ id }) => store.getAnnotation(id)!);\n\n    updatedSelected.forEach(updated => {\n      const initial = initialSelection.find(a => a.id === updated.id);\n      if (!initial || !dequal(initial, updated)) {\n        emit('updateAnnotation', updated, initial);\n      }\n    });\n\n    initialSelection = initialSelection.map(initial => {\n      const updated = updatedSelected.find(({ id }) => id === initial.id);\n      return updated ? updated : initial\n    });\n  }\n\n  selection.subscribe(({ selected })=> {\n    if (initialSelection.length === 0 && selected.length === 0)\n      return;\n\n    if (initialSelection.length === 0 && selected.length > 0) {\n      // A new selection was made - store the editable annotation as initial state\n      initialSelection = selected.map(({ id }) => store.getAnnotation(id)!);\n    } else if (initialSelection.length > 0 && selected.length === 0) {\n      // Deselect!\n      initialSelection.forEach(initial => {\n        const updatedState = store.getAnnotation(initial.id);  \n        \n        if (updatedState && !dequal(updatedState, initial)) {\n          emit('updateAnnotation', updatedState, initial);\n        }\n      });\n\n      initialSelection = [];\n    } else {\n      // Changed selection\n      const initialIds = new Set(initialSelection.map(a => a.id));\n      const selectedIds = new Set(selected.map(({ id }) => id));\n\n      // Fire update events for deselected annotations that have changed\n      const deselected = initialSelection.filter(a => !selectedIds.has(a.id));\n      deselected.forEach(initial => {\n        const updatedState = store.getAnnotation(initial.id);\n\n        if (updatedState && !dequal(updatedState, initial))\n          emit('updateAnnotation', updatedState, initial);\n      });\n\n      initialSelection = [\n        // Remove annotations that were deselected\n        ...initialSelection.filter(a => selectedIds.has(a.id)),\n        // Add editable annotations that were selected\n        ...selected\n          .filter(({ id }) => !initialIds.has(id))\n          .map(({ id }) => store.getAnnotation(id)!)\n      ];\n    }\n\n    emit('selectionChanged', initialSelection);\n  });\n\n  hover.subscribe(id => {\n    if (!currentHover && id) {\n      emit('mouseEnterAnnotation', store.getAnnotation(id)!);\n    } else if (currentHover && !id) {\n      emit('mouseLeaveAnnotation', store.getAnnotation(currentHover)!);\n    } else if (currentHover && id) {\n      emit('mouseLeaveAnnotation', store.getAnnotation(currentHover)!);\n      emit('mouseEnterAnnotation', store.getAnnotation(id)!);\n    }\n\n    currentHover = id;\n  });\n\n  viewport?.subscribe(ids => \n    emit('viewportIntersect', ids.map(id => store.getAnnotation(id)!)));\n\n  store.observe(event => {\n    // autoSave option triggers update events on idleness\n    if (autoSave) {\n      if (idleTimeout)\n        clearTimeout(idleTimeout);\n\n      idleTimeout = setTimeout(onIdleUpdate, 1000);\n    }\n\n    // Local CREATE and DELETE events are applied immediately\n    const { created, deleted } = event.changes;\n    (created || []).forEach(a => emit('createAnnotation', a));\n    (deleted || []).forEach(a => emit('deleteAnnotation', a));\n\n    // Updates are only applied immediately if they involve body changes\n    const updatesWithBody = (event.changes.updated || []).filter(u => [\n      ...(u.bodiesCreated || []),\n      ...(u.bodiesDeleted || []),\n      ...(u.bodiesUpdated || [])\n    ].length > 0);\n\n    // Emit an update with the new annototation and the stored initial state\n    updatesWithBody.forEach(({ oldValue, newValue }) => {\n      const initial = initialSelection.find(a => a.id === oldValue.id) || oldValue;\n\n      // Record the update as the new last known state\n      initialSelection = initialSelection\n        .map(a => a.id === oldValue.id ? newValue : a);\n\n      emit('updateAnnotation', newValue, initial);\n    });\n  }, { origin: Origin.LOCAL });\n\n  // Track remote changes - these should update the initial state\n  store.observe(event => {\n    if (initialSelection) {\n      const selectedIds = new Set(initialSelection.map(a => a.id));\n\n      const relevantUpdates = (event.changes.updated || [])\n        .filter(({ newValue }) => selectedIds.has(newValue.id))\n        .map(({ newValue }) => newValue);\n\n      if (relevantUpdates.length > 0) {\n        initialSelection = initialSelection.map(selected => {\n          const updated = relevantUpdates.find(updated => updated.id === selected.id);\n          return updated ? updated : selected;\n        })\n      }\n    }\n  }, { origin: Origin.REMOTE });\n\n  const onUndoOrRedo = (undo: boolean) => (changes: ChangeSet<I>) => {\n    // Undo/redo of created/delete will cause lifecycle events automatically,\n    // but we need to handle udpates specifically!\n    const { updated } = changes;\n\n    if (undo)\n      (updated || []).forEach(t => emit('updateAnnotation', t.oldValue, t.newValue));\n    else\n      (updated || []).forEach(t => emit('updateAnnotation', t.newValue, t.oldValue));\n  }\n\n  undoStack.on('undo', onUndoOrRedo(true));\n  undoStack.on('redo', onUndoOrRedo(false));\n\n  return { on, off, emit }\n\n}","import type { Annotation } from './Annotation';\n\nexport interface FormatAdapter<A extends Annotation, T extends unknown> {\n\n  parse(serialized: T): ParseResult<A>;\n\n  serialize(core: A): T;\n\n}\n\nexport interface ParseResult<A extends Annotation> {\n\n  parsed?: A;\n  \n  error?: Error;\n\n}\n\nexport const serializeAll = \n  <A extends Annotation, T extends unknown>(adapter: FormatAdapter<A, T>) =>\n    (annotations: A[]) => annotations.map(a => adapter.serialize(a));\n\nexport const parseAll = \n  <A extends Annotation, T extends unknown>(adapter: FormatAdapter<A, T>) =>\n    (serialized: T[]) => serialized.reduce((result, next) => {\n      const { parsed, error } = adapter.parse(next);\n      \n      return error ? {\n        parsed: result.parsed,\n        failed: [...result.failed, next ]\n      } : parsed ? {\n        parsed: [...result.parsed, parsed ],\n        failed: result.failed\n      } : {\n        ...result\n      }\n    }, { parsed: [] as A[], failed: [] as T[]});\n  ","import type { Annotation } from './Annotation';\nimport type { User } from './User';\nimport type { PresenceProvider } from '../presence/PresenceProvider';\nimport { Origin, type HoverState, type SelectionState, type Store, type UndoStack, type ViewportState } from '../state';\nimport type { LifecycleEvents } from '../lifecycle/LifecycleEvents';\nimport { parseAll, type FormatAdapter } from './FormatAdapter';\nimport type { DrawingStyleExpression } from './DrawingStyle';\nimport type { Filter } from './Filter';\n\n/**\n * Base annotator interface\n * @template I - internal core data model\n * @template E - external adapted representation\n */\nexport interface Annotator<I extends Annotation = Annotation, E extends unknown = Annotation> {\n\n  addAnnotation(annotation: E): void;\n\n  cancelSelected(): void;\n\n  canRedo(): boolean;\n\n  canUndo(): boolean;\n\n  clearAnnotations(): void;\n\n  destroy(): void;\n\n  getAnnotationById(id: string): E | undefined;\n\n  getAnnotations(): E[];\n\n  getSelected(): E[];\n\n  getUser(): User;\n\n  loadAnnotations(url: string, replace?: boolean): Promise<E[]>;\n\n  redo(): void;\n\n  removeAnnotation(arg: E | string): E | undefined;\n\n  setAnnotations(annotations: E[], replace?: boolean): void;\n\n  setFilter(filter: Filter | undefined): void;\n\n  setPresenceProvider?(provider: PresenceProvider): void;\n\n  setSelected(arg?: string | string[]): void;\n\n  setStyle(style: DrawingStyleExpression<I> | undefined): void;\n\n  setUser(user: User): void;\n\n  setVisible(visible: boolean): void;\n\n  undo(): void;\n\n  updateAnnotation(annotation: E): E;\n  \n  on<T extends keyof LifecycleEvents<E>>(event: T, callback: LifecycleEvents<E>[T]): void;\n\n  off<T extends keyof LifecycleEvents<E>>(event: T, callback: LifecycleEvents<E>[T]): void;\n\n  state: AnnotatorState<I>;\n\n}\n\nexport interface AnnotatorState<A extends Annotation> {\n\n  store: Store<A>;\n\n  selection: SelectionState<A>;\n\n  hover: HoverState<A>;\n\n  viewport: ViewportState;\n\n}\n\nexport const createBaseAnnotator = <I extends Annotation, E extends unknown>(\n  state: AnnotatorState<I>, \n  undoStack: UndoStack<I>,\n  adapter?: FormatAdapter<I, E>\n) => {\n\n  const { store, selection } = state;\n\n  const addAnnotation = (annotation: E) => {\n    if (adapter) {\n      const { parsed, error } = adapter.parse(annotation);\n      if (parsed) {\n        store.addAnnotation(parsed, Origin.REMOTE);\n      } else {\n        console.error(error);\n      }\n    } else {\n      store.addAnnotation(annotation as unknown as I, Origin.REMOTE);\n    }\n  }\n\n  const cancelSelected = () => selection.clear();\n\n  const clearAnnotations = () => store.clear();\n\n  const getAnnotationById = (id: string): E | undefined => {\n    const annotation = store.getAnnotation(id);\n    return (adapter && annotation) ?\n      adapter.serialize(annotation) as E : annotation as unknown as E;\n  }\n\n  const getAnnotations = () =>\n    (adapter ? store.all().map(adapter.serialize) : store.all()) as E[];\n\n  const getSelected = () => {\n    const selectedIds = selection.selected?.map(s => s.id) || [];\n\n    const selected = selectedIds.map(id => store.getAnnotation(id)!).filter(Boolean);\n\n    return adapter \n      ? selected.map(adapter.serialize) \n      : selected as unknown as E[];\n  }\n\n  const loadAnnotations = (url: string, replace = true) =>\n    fetch(url)\n      .then((response) => response.json())\n      .then((annotations) => {\n        setAnnotations(annotations, replace);\n        return annotations;\n      });\n\n  const removeAnnotation = (arg: E | string): E | undefined => {\n    if (typeof arg === 'string') {\n      const annotation = store.getAnnotation(arg);\n      store.deleteAnnotation(arg);\n\n      if (annotation)\n        return adapter ? adapter.serialize(annotation) : annotation as unknown as E;\n    } else {\n      const annotation = adapter ? adapter.parse(arg).parsed : (arg as unknown as I);\n\n      if (annotation) {\n        store.deleteAnnotation(annotation);\n        return arg;\n      }\n    }\n  }\n\n  const setAnnotations = (annotations: E[], replace = true) => {\n    if (adapter) {\n      const { parsed, failed } = parseAll(adapter)(annotations);\n\n      if (failed.length > 0)\n        console.warn(`Discarded ${failed.length} invalid annotations`, failed);\n\n      store.bulkAddAnnotation(parsed, replace, Origin.REMOTE);\n    } else {\n      store.bulkAddAnnotation(annotations as unknown as I[], replace, Origin.REMOTE);\n    }\n  }\n\n  const setSelected = (arg?: string | string[]) => {\n    if (arg) {\n      selection.setSelected(arg);\n    } else {\n      selection.clear();\n    }\n  }\n\n  const updateAnnotation = (updated: E): E => {\n    if (adapter) {\n      const crosswalked = adapter.parse(updated).parsed!;\n      const previous = adapter.serialize(store.getAnnotation(crosswalked.id)!);\n      store.updateAnnotation(crosswalked);\n      return previous;\n    } else {\n      const previous = store.getAnnotation((updated as unknown as I).id);\n      store.updateAnnotation(updated as unknown as I);\n      return previous as unknown as E;\n    }\n  }\n\n  // Note that we don't spread the undoStack - it has a .destroy()\n  // method that would likely get overwritten by other Annotator implementations\n  // if people are not careful.\n  return { \n    addAnnotation,\n    cancelSelected,\n    canRedo: undoStack.canRedo,\n    canUndo: undoStack.canUndo,\n    clearAnnotations,\n    getAnnotationById,\n    getAnnotations,\n    getSelected,\n    loadAnnotations,\n    redo: undoStack.redo,\n    removeAnnotation,\n    setAnnotations,\n    setSelected,\n    undo: undoStack.undo,\n    updateAnnotation\n  }\n\n}\n","export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n","import { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array(size))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n","import { customAlphabet } from 'nanoid';\n\nexport interface User {\n\n  id: string;\n\n  isGuest?: boolean;\n\n  name?: string;\n\n  avatar?: string;\n\n}\n\nexport const createAnonymousGuest = () => {\n  const nanoid = customAlphabet('1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_', 20);\n  \n  return { isGuest: true, id: nanoid() }\n}","import type { AnnotationBody } from './Annotation';\n\nexport interface W3CAnnotation {\n\n  '@context': 'http://www.w3.org/ns/anno.jsonld';\n\n  type: 'Annotation';\n\n  id: string;\n\n  created?: string;\n\n  creator?: W3CUser;\n\n  modified?: string;\n\n  body: W3CAnnotationBody | W3CAnnotationBody[];\n\n  target: W3CAnnotationTarget | W3CAnnotationTarget[];\n\n  [key: string]: any;\n\n}\n\nexport interface W3CUser {\n\n  type?: string;\n\n  id: string;\n\n  name?: string;\n\n}\n\nexport interface W3CAnnotationBody {\n\n  type?: string;\n\n  id?: string;\n\n  purpose?: string;\n\n  value?: string;\n\n  source?: string;\n\n  created?: string;\n\n  creator?: W3CUser;\n\n}\n\nexport interface W3CAnnotationTarget {\n\n  id?: string;\n\n  source: string;\n\n  selector?: AbstractW3CSelector;\n\n}\n\nexport interface AbstractW3CSelector { }\n\n// https://stackoverflow.com/questions/6122571/simple-non-secure-hash-function-for-javascript\nconst hashCode = (obj: Object): string => {\n  const str = JSON.stringify(obj);\n\n  let hash = 0;\n\n  for (let i = 0, len = str.length; i < len; i++) {\n    let chr = str.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return `${hash}`;\n}\n\nexport const parseW3CUser = (user?: any) => user\n  ? typeof user === 'object' ? { ...user } : user : undefined;\n\n/**\n * Helper to crosswalk the W3C annotation body to a list of core AnnotationBody objects.\n */\nexport const parseW3CBodies = (\n  body: W3CAnnotationBody | W3CAnnotationBody[],\n  annotationId: string\n) : AnnotationBody[] => (Array.isArray(body) ? body : [body]).map(body => {\n\n  // Exctract properties that conform to the internal model, but keep custom props\n  const { id, type, purpose, value, created, creator, ...rest } = body;\n\n  // The internal model strictly requires IDs. (Because multi-user scenarios\n  // will have problems without them.) In the W3C model, bodys *may* have IDs.\n  // We'll create ad-hoc IDs for bodies without IDs, but want to make sure that\n  // generating the ID is idempotent: the same body should always get the same ID.\n  // This will avoid unexpected results when checking for equality.  \n  return {\n    id: id || `temp-${hashCode(body)}`,\n    annotation: annotationId,\n    type,\n    purpose,\n    value,\n    created: created ? new Date(created) : undefined,\n    creator: parseW3CUser(creator),\n    ...rest\n  }\n\n});\n\n/** Serialization helper to remove core-specific fields from the annotation body **/\nexport const serializeW3CBodies = (bodies: AnnotationBody[]): W3CAnnotationBody[] =>\n  bodies.map(b => {\n    const w3c = { ...b } as any;\n    delete w3c.annotation;\n\n    if (w3c.id?.startsWith('temp-'))\n      delete w3c.id;\n\n    return { ...w3c, created: w3c.created?.toISOString() };\n  });\n","// SEABORN_BRIGHT\nexport const DEFAULT_PALETTE: Palette = [\n  '#ff7c00', // orange\n  '#1ac938', // green\n  '#e8000b', // red\n  '#8b2be2', // purple\n  '#9f4800', // brown\n  '#f14cc1', // pink\n  '#ffc400', // khaki\n  '#00d7ff', // cyan\n  '#023eff'  // blue\n];\n\nexport type Palette = string[];","import type { User } from '../model/User';\nimport type { Appearance } from './Appearance';\nimport type { PresentUser } from './PresentUser';\nimport { DEFAULT_PALETTE } from './ColorPalette';\n\nexport interface AppearanceProvider {\n\n  addUser(presenceKey: string, user: User): Appearance;\n\n  removeUser(user: PresentUser): void;\n\n}\n\nexport const defaultColorProvider = () => {\n\n  const unassignedColors = [...DEFAULT_PALETTE];\n\n  const assignRandomColor = () => {\n    const rnd = Math.floor(Math.random() * unassignedColors.length);\n    const color = unassignedColors[rnd];\n\n    unassignedColors.splice(rnd, 1);\n\n    return color;\n  }\n\n  const releaseColor = (color: string) =>\n    unassignedColors.push(color);\n\n  return { assignRandomColor, releaseColor };\n\n}\n\nexport const createDefaultAppearenceProvider = () => {\n\n  const colorProvider = defaultColorProvider();\n\n  const addUser = (presenceKey: string, user: User): Appearance => {\n    const color = colorProvider.assignRandomColor();\n\n    return {\n      label: user.name || user.id,\n      avatar: user.avatar,\n      color\n    };\n  }\n\n  const removeUser = (user: PresentUser) =>\n    colorProvider.releaseColor(user.appearance.color);\n\n  return { addUser, removeUser }\n  \n}","import { nanoid } from 'nanoid';\nimport { createNanoEvents, type Unsubscribe } from 'nanoevents';\nimport type { User } from '../model/User';\nimport type { PresentUser } from './PresentUser';\nimport type { PresenceEvents } from './PresenceEvents';\nimport { createDefaultAppearenceProvider } from './AppearanceProvider';\nimport type { AppearanceProvider } from './AppearanceProvider';\n\nexport interface PresenceState {\n\n  // Get users currently present to this room\n  getPresentUsers(): PresentUser[];\n\n  // Notify of a given present user's activity on the given annotations\n  notifyActivity(presenceKey: string, annotationIds: string[]): void;\n\n  // Add a listener for the given presence event\n  on<E extends keyof PresenceEvents>(event: E, callback: PresenceEvents[E]): Unsubscribe;\n\n  // Initial sync - which users are present under which keys\n  syncUsers(state: { presenceKey: string, user: User }[]): void;\n\n  // Update the selection state for the given prresent user\n  updateSelection(presenceKey: string, selection: string[] | null): void;\n\n}\n\nconst isListEqual = (listA: any[], listB: any[]) => \n  listA.every(a => listA.includes(a)) && listB.every(b => listA.includes(b));\n\n// This client's presence key\nexport const PRESENCE_KEY = nanoid();\n\nexport const createPresenceState = (\n  appearanceProvider: AppearanceProvider = createDefaultAppearenceProvider()\n): PresenceState => {\n\n  const emitter = createNanoEvents<PresenceEvents>();\n\n  const presentUsers = new Map<string, PresentUser>();\n\n  const selectionStates = new Map<string, string[]>();\n\n  const addUser = (presenceKey: string, user: User) => {\n    if (presentUsers.has(presenceKey)) {\n      console.warn('Attempt to add user that is already present', presenceKey, user);\n      return;    \n    }\n\n    const appearance = appearanceProvider.addUser(presenceKey, user);\n\n    presentUsers.set(presenceKey, { \n      ...user,\n      presenceKey,\n      appearance\n    });\n  }\n\n  const removeUser = (presenceKey: string) => {\n    const user = presentUsers.get(presenceKey);\n    if (!user) {\n      console.warn('Attempt to remove user that is not present', presenceKey);\n      return;\n    }\n\n    appearanceProvider.removeUser(user);\n\n    presentUsers.delete(presenceKey);\n  }\n\n  const syncUsers = (state: { presenceKey: string, user: User }[]) => {\n    // const keys = new Set(others.map(s => s.presenceKey));\n    const keys = new Set(state.map(s => s.presenceKey));\n\n    // These users need to be added to the presentUsers list\n    // const toAdd = others.filter(({ presenceKey }) => !presentUsers.has(presenceKey));\n    const toAdd = state.filter(({ presenceKey }) => !presentUsers.has(presenceKey));\n\n    // These users need to be dropped from the list\n    const toRemove = Array.from(presentUsers.values()).filter(presentUser =>\n      !keys.has(presentUser.presenceKey));\n\n    toAdd.forEach(({ presenceKey, user }) => addUser(presenceKey, user));\n\n    toRemove.forEach(user => {\n      const { presenceKey } = user;\n\n      // If this user has a selection, fire deselect event\n      if (selectionStates.has(presenceKey))\n        emitter.emit('selectionChange', user, null);\n\n      removeUser(presenceKey)\n    });\n\n    if (toAdd.length > 0 || toRemove.length > 0)\n      emitter.emit('presence', getPresentUsers());\n  }\n\n  const notifyActivity = (presenceKey: string, annotationIds: string[]) => {    \n    const user = presentUsers.get(presenceKey);\n    \n    if (!user) {\n      console.warn('Activity notification from user that is not present');\n      return;\n    }\n\n    const currentSelection = selectionStates.get(presenceKey);\n\n    // Was there a selection change we might have missed?\n    if (!currentSelection || !isListEqual(currentSelection, annotationIds)) {\n      selectionStates.set(presenceKey, annotationIds);\n      emitter.emit('selectionChange', user, annotationIds);\n    }\n  }\n\n  const updateSelection = (presenceKey: string, selection: string[] | null) => {\n    const from = presentUsers.get(presenceKey);\n    if (!from) {\n      console.warn('Selection change for user that is not present', presenceKey);\n      return;\n    }\n\n    if (selection)\n      selectionStates.set(presenceKey, selection);\n    else \n      selectionStates.delete(presenceKey);\n\n    emitter.emit('selectionChange', from, selection);\n  }\n\n  const getPresentUsers = () =>\n    [...Array.from(presentUsers.values())];\n    \n  const on = <E extends keyof PresenceEvents>(event: E, callback: PresenceEvents[E]) =>\n    emitter.on(event, callback);\n\n  return {\n    getPresentUsers,\n    notifyActivity,\n    on,\n    syncUsers,\n    updateSelection\n  }\n\n}"],"names":["has","dequal","foo","bar","ctor","len","noop","safe_not_equal","a","b","subscriber_queue","writable","value","start","stop","subscribers","set","new_value","run_queue","subscriber","i","update","fn","subscribe","run","invalidate","createHoverState","store","currentHover","updated","changes","oldValue","PointerSelectAction","EMPTY","createSelectionState","selectAction","currentSelection","clear","isEmpty","_a","isSelected","annotationOrId","id","clickSelect","pointerEvent","annotation","action","onPointerSelect","setSelected","idOrIds","editable","ids","annotations","removeFromSelection","selected","getRandomValues","rnds8","rng","byteToHex","unsafeStringify","arr","offset","randomUUID","native","v4","options","buf","rnds","getContributors","creator","updatedBy","bodyCollaborators","users","body","u","createBody","payload","created","uuidv4","getAddedBodies","newValue","oldBodyIds","getRemovedBodies","newBodyIds","getChangedBodies","newBody","oldBody","hasTargetChanged","diffAnnotations","bodiesCreated","bodiesDeleted","bodiesUpdated","Ignore","Origin","shouldNotify","observer","event","_b","origin","ignore","arg","hasBodyChanges","hasTargetChanges","affectedAnnotations","mergeChanges","toMerge","previouslyCreatedIds","previouslyUpdatedIds","createdIds","deletedIds","updatedIds","mergeableUpdates","deleted","isAnnotation","createStore","annotationIndex","bodyIndex","observers","observe","onChange","unobserve","idx","emit","addAnnotation","updateOneAnnotation","arg1","arg2","oldId","updateAnnotation","arg3","bulkUpdateAnnotation","addBody","all","bulkAddAnnotation","replace","existing","next","deleteOneAnnotation","deleteAnnotation","bulkDeleteAnnotation","annotationsOrIds","deleteOneBody","oldAnnotation","newAnnotation","deleteBody","bulkDeleteBodies","bodies","getAnnotation","getBody","annotationId","updateOneBody","oldBodyId","updateBody","bulkUpdateBodies","updateOneTarget","target","targets","t","toSvelteStore","shim","createNanoEvents","args","callbacks","length","cb","DEBOUNCE","createUndoStack","emitter","changeStack","pointer","muteEvents","lastEvent","now","last","undoCreated","redoCreated","undoUpdated","redoUpdated","undoDeleted","redoDeleted","callback","createViewportState","createLifecyleObserver","state","undoStack","adapter","autoSave","selection","hover","viewport","initialSelection","idleTimeout","on","off","arg0","serialized0","serialized1","onIdleUpdate","updatedSelected","initial","updatedState","initialIds","selectedIds","relevantUpdates","onUndoOrRedo","undo","serializeAll","parseAll","serialized","result","parsed","error","createBaseAnnotator","cancelSelected","clearAnnotations","getAnnotationById","getAnnotations","getSelected","s","loadAnnotations","url","response","setAnnotations","removeAnnotation","failed","crosswalked","previous","urlAlphabet","random","bytes","customRandom","alphabet","defaultSize","getRandom","mask","step","size","j","customAlphabet","nanoid","scopedUrlAlphabet","createAnonymousGuest","hashCode","obj","str","hash","chr","parseW3CUser","user","parseW3CBodies","type","purpose","rest","serializeW3CBodies","w3c","DEFAULT_PALETTE","defaultColorProvider","unassignedColors","rnd","color","createDefaultAppearenceProvider","colorProvider","presenceKey","isListEqual","listA","listB","PRESENCE_KEY","createPresenceState","appearanceProvider","presentUsers","selectionStates","addUser","appearance","removeUser","syncUsers","keys","toAdd","toRemove","presentUser","getPresentUsers","notifyActivity","annotationIds","updateSelection","from"],"mappings":"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","x_google_ignoreList":[0,1,2,5,6,7,8,14,20,21]}