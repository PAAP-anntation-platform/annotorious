{"version":3,"file":"colorToUniform-B7LFXjB6.js","sources":["../../../node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/types.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs","../../../node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs","../../../node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs","../../../node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs","../../../node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs","../../../node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs","../../../node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs","../../../node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs","../../../node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs","../../../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs","../../../node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs","../../../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs","../../../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs","../../../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs","../../../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","../../../node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs","../../../node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"],"sourcesContent":["\"use strict\";\nconst idCounts = /* @__PURE__ */ Object.create(null);\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createIdFromString(value, groupId) {\n  let id = idHash[value];\n  if (id === void 0) {\n    if (idCounts[groupId] === void 0) {\n      idCounts[groupId] = 1;\n    }\n    idHash[value] = id = idCounts[groupId]++;\n  }\n  return id;\n}\n\nexport { createIdFromString };\n//# sourceMappingURL=createIdFromString.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\n\n\"use strict\";\nlet context;\nfunction getTestContext() {\n  if (!context || context?.isContextLost()) {\n    const canvas = DOMAdapter.get().createCanvas();\n    context = canvas.getContext(\"webgl\", {});\n  }\n  return context;\n}\n\nexport { getTestContext };\n//# sourceMappingURL=getTestContext.mjs.map\n","import { getTestContext } from './getTestContext.mjs';\n\n\"use strict\";\nlet maxFragmentPrecision;\nfunction getMaxFragmentPrecision() {\n  if (!maxFragmentPrecision) {\n    maxFragmentPrecision = \"mediump\";\n    const gl = getTestContext();\n    if (gl) {\n      if (gl.getShaderPrecisionFormat) {\n        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n        maxFragmentPrecision = shaderFragment.precision ? \"highp\" : \"mediump\";\n      }\n    }\n  }\n  return maxFragmentPrecision;\n}\n\nexport { getMaxFragmentPrecision };\n//# sourceMappingURL=getMaxFragmentPrecision.mjs.map\n","\"use strict\";\nfunction addProgramDefines(src, isES300, isFragment) {\n  if (isES300)\n    return src;\n  if (isFragment) {\n    src = src.replace(\"out vec4 finalColor;\", \"\");\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n  }\n  return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n\nexport { addProgramDefines };\n//# sourceMappingURL=addProgramDefines.mjs.map\n","\"use strict\";\nfunction ensurePrecision(src, options, isFragment) {\n  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n  if (src.substring(0, 9) !== \"precision\") {\n    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n    if (precision === \"highp\" && maxSupportedPrecision !== \"highp\") {\n      precision = \"mediump\";\n    }\n    return `precision ${precision} float;\n${src}`;\n  } else if (maxSupportedPrecision !== \"highp\" && src.substring(0, 15) === \"precision highp\") {\n    return src.replace(\"precision highp\", \"precision mediump\");\n  }\n  return src;\n}\n\nexport { ensurePrecision };\n//# sourceMappingURL=ensurePrecision.mjs.map\n","\"use strict\";\nfunction insertVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return `#version 300 es\n${src}`;\n}\n\nexport { insertVersion };\n//# sourceMappingURL=insertVersion.mjs.map\n","\"use strict\";\nconst fragmentNameCache = {};\nconst VertexNameCache = {};\nfunction setProgramName(src, { name = `pixi-program` }, isFragment = true) {\n  name = name.replace(/\\s+/g, \"-\");\n  name += isFragment ? \"-fragment\" : \"-vertex\";\n  const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n  if (nameCache[name]) {\n    nameCache[name]++;\n    name += `-${nameCache[name]}`;\n  } else {\n    nameCache[name] = 1;\n  }\n  if (src.indexOf(\"#define SHADER_NAME\") !== -1)\n    return src;\n  const shaderName = `#define SHADER_NAME ${name}`;\n  return `${shaderName}\n${src}`;\n}\n\nexport { setProgramName };\n//# sourceMappingURL=setProgramName.mjs.map\n","\"use strict\";\nfunction stripVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return src.replace(\"#version 300 es\", \"\");\n}\n\nexport { stripVersion };\n//# sourceMappingURL=stripVersion.mjs.map\n","import { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision.mjs';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines.mjs';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision.mjs';\nimport { insertVersion } from './program/preprocessors/insertVersion.mjs';\nimport { setProgramName } from './program/preprocessors/setProgramName.mjs';\nimport { stripVersion } from './program/preprocessors/stripVersion.mjs';\n\n\"use strict\";\nconst processes = {\n  // strips any version headers..\n  stripVersion,\n  // adds precision string if not already present\n  ensurePrecision,\n  // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n  addProgramDefines,\n  // add the program name to the shader\n  setProgramName,\n  // add the version string to the shader header\n  insertVersion\n};\nconst programCache = /* @__PURE__ */ Object.create(null);\nconst _GlProgram = class _GlProgram {\n  /**\n   * Creates a shiny new GlProgram. Used by WebGL renderer.\n   * @param options - The options for the program.\n   */\n  constructor(options) {\n    options = { ..._GlProgram.defaultOptions, ...options };\n    const isES300 = options.fragment.indexOf(\"#version 300 es\") !== -1;\n    const preprocessorOptions = {\n      stripVersion: isES300,\n      ensurePrecision: {\n        requestedFragmentPrecision: options.preferredFragmentPrecision,\n        requestedVertexPrecision: options.preferredVertexPrecision,\n        maxSupportedVertexPrecision: \"highp\",\n        maxSupportedFragmentPrecision: getMaxFragmentPrecision()\n      },\n      setProgramName: {\n        name: options.name\n      },\n      addProgramDefines: isES300,\n      insertVersion: isES300\n    };\n    let fragment = options.fragment;\n    let vertex = options.vertex;\n    Object.keys(processes).forEach((processKey) => {\n      const processOptions = preprocessorOptions[processKey];\n      fragment = processes[processKey](fragment, processOptions, true);\n      vertex = processes[processKey](vertex, processOptions, false);\n    });\n    this.fragment = fragment;\n    this.vertex = vertex;\n    this._key = createIdFromString(`${this.vertex}:${this.fragment}`, \"gl-program\");\n  }\n  /** destroys the program */\n  destroy() {\n    this.fragment = null;\n    this.vertex = null;\n    this._attributeData = null;\n    this._uniformData = null;\n    this._uniformBlockData = null;\n    this.transformFeedbackVaryings = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex}:${options.fragment}`;\n    if (!programCache[key]) {\n      programCache[key] = new _GlProgram(options);\n    }\n    return programCache[key];\n  }\n};\n/** The default options used by the program. */\n_GlProgram.defaultOptions = {\n  preferredVertexPrecision: \"highp\",\n  preferredFragmentPrecision: \"mediump\"\n};\nlet GlProgram = _GlProgram;\n\nexport { GlProgram };\n//# sourceMappingURL=GlProgram.mjs.map\n","\"use strict\";\nconst attributeFormatData = {\n  uint8x2: { size: 2, stride: 2, normalised: false },\n  uint8x4: { size: 4, stride: 4, normalised: false },\n  sint8x2: { size: 2, stride: 2, normalised: false },\n  sint8x4: { size: 4, stride: 4, normalised: false },\n  unorm8x2: { size: 2, stride: 2, normalised: true },\n  unorm8x4: { size: 4, stride: 4, normalised: true },\n  snorm8x2: { size: 2, stride: 2, normalised: true },\n  snorm8x4: { size: 4, stride: 4, normalised: true },\n  uint16x2: { size: 2, stride: 4, normalised: false },\n  uint16x4: { size: 4, stride: 8, normalised: false },\n  sint16x2: { size: 2, stride: 4, normalised: false },\n  sint16x4: { size: 4, stride: 8, normalised: false },\n  unorm16x2: { size: 2, stride: 4, normalised: true },\n  unorm16x4: { size: 4, stride: 8, normalised: true },\n  snorm16x2: { size: 2, stride: 4, normalised: true },\n  snorm16x4: { size: 4, stride: 8, normalised: true },\n  float16x2: { size: 2, stride: 4, normalised: false },\n  float16x4: { size: 4, stride: 8, normalised: false },\n  float32: { size: 1, stride: 4, normalised: false },\n  float32x2: { size: 2, stride: 8, normalised: false },\n  float32x3: { size: 3, stride: 12, normalised: false },\n  float32x4: { size: 4, stride: 16, normalised: false },\n  uint32: { size: 1, stride: 4, normalised: false },\n  uint32x2: { size: 2, stride: 8, normalised: false },\n  uint32x3: { size: 3, stride: 12, normalised: false },\n  uint32x4: { size: 4, stride: 16, normalised: false },\n  sint32: { size: 1, stride: 4, normalised: false },\n  sint32x2: { size: 2, stride: 8, normalised: false },\n  sint32x3: { size: 3, stride: 12, normalised: false },\n  sint32x4: { size: 4, stride: 16, normalised: false }\n};\nfunction getAttributeInfoFromFormat(format) {\n  return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n\nexport { getAttributeInfoFromFormat };\n//# sourceMappingURL=getAttributeInfoFromFormat.mjs.map\n","import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nconst WGSL_TO_VERTEX_TYPES = {\n  f32: \"float32\",\n  \"vec2<f32>\": \"float32x2\",\n  \"vec3<f32>\": \"float32x3\",\n  \"vec4<f32>\": \"float32x4\",\n  vec2f: \"float32x2\",\n  vec3f: \"float32x3\",\n  vec4f: \"float32x4\",\n  i32: \"sint32\",\n  \"vec2<i32>\": \"sint32x2\",\n  \"vec3<i32>\": \"sint32x3\",\n  \"vec4<i32>\": \"sint32x4\",\n  u32: \"uint32\",\n  \"vec2<u32>\": \"uint32x2\",\n  \"vec3<u32>\": \"uint32x3\",\n  \"vec4<u32>\": \"uint32x4\",\n  bool: \"uint32\",\n  \"vec2<bool>\": \"uint32x2\",\n  \"vec3<bool>\": \"uint32x3\",\n  \"vec4<bool>\": \"uint32x4\"\n};\nfunction extractAttributesFromGpuProgram({ source, entryPoint }) {\n  const results = {};\n  const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n  if (mainVertStart !== -1) {\n    const arrowFunctionStart = source.indexOf(\"->\", mainVertStart);\n    if (arrowFunctionStart !== -1) {\n      const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n      const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n      let match;\n      while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {\n        const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? \"float32\";\n        results[match[2]] = {\n          location: parseInt(match[1], 10),\n          format,\n          stride: getAttributeInfoFromFormat(format).stride,\n          offset: 0,\n          instance: false,\n          start: 0\n        };\n      }\n    }\n  }\n  return results;\n}\n\nexport { extractAttributesFromGpuProgram };\n//# sourceMappingURL=extractAttributesFromGpuProgram.mjs.map\n","\"use strict\";\nfunction extractStructAndGroups(wgsl) {\n  const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n  const groupPattern = /@group\\((\\d+)\\)/;\n  const bindingPattern = /@binding\\((\\d+)\\)/;\n  const namePattern = /var(<[^>]+>)? (\\w+)/;\n  const typePattern = /:\\s*(\\w+)/;\n  const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n  const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n  const structName = /struct\\s+(\\w+)/;\n  const groups = wgsl.match(linePattern)?.map((item) => ({\n    group: parseInt(item.match(groupPattern)[1], 10),\n    binding: parseInt(item.match(bindingPattern)[1], 10),\n    name: item.match(namePattern)[2],\n    isUniform: item.match(namePattern)[1] === \"<uniform>\",\n    type: item.match(typePattern)[1]\n  }));\n  if (!groups) {\n    return {\n      groups: [],\n      structs: []\n    };\n  }\n  const structs = wgsl.match(structPattern)?.map((struct) => {\n    const name = struct.match(structName)[1];\n    const members = struct.match(structMemberPattern).reduce((acc, member) => {\n      const [name2, type] = member.split(\":\");\n      acc[name2.trim()] = type.trim();\n      return acc;\n    }, {});\n    if (!members) {\n      return null;\n    }\n    return { name, members };\n  }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n  return {\n    groups,\n    structs\n  };\n}\n\nexport { extractStructAndGroups };\n//# sourceMappingURL=extractStructAndGroups.mjs.map\n","\"use strict\";\nvar ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {\n  ShaderStage2[ShaderStage2[\"VERTEX\"] = 1] = \"VERTEX\";\n  ShaderStage2[ShaderStage2[\"FRAGMENT\"] = 2] = \"FRAGMENT\";\n  ShaderStage2[ShaderStage2[\"COMPUTE\"] = 4] = \"COMPUTE\";\n  return ShaderStage2;\n})(ShaderStage || {});\n\nexport { ShaderStage };\n//# sourceMappingURL=const.mjs.map\n","import { ShaderStage } from '../../../shared/shader/const.mjs';\n\n\"use strict\";\nfunction generateGpuLayoutGroups({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = [];\n    }\n    if (group.isUniform) {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n        buffer: {\n          type: \"uniform\"\n        }\n      });\n    } else if (group.type === \"sampler\") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.FRAGMENT,\n        sampler: {\n          type: \"filtering\"\n        }\n      });\n    } else if (group.type === \"texture_2d\") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.FRAGMENT,\n        texture: {\n          sampleType: \"float\",\n          viewDimension: \"2d\",\n          multisampled: false\n        }\n      });\n    }\n  }\n  return layout;\n}\n\nexport { generateGpuLayoutGroups };\n//# sourceMappingURL=generateGpuLayoutGroups.mjs.map\n","\"use strict\";\nfunction generateLayoutHash({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = {};\n    }\n    layout[group.group][group.name] = group.binding;\n  }\n  return layout;\n}\n\nexport { generateLayoutHash };\n//# sourceMappingURL=generateLayoutHash.mjs.map\n","\"use strict\";\nfunction removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {\n  const structNameSet = /* @__PURE__ */ new Set();\n  const dupeGroupKeySet = /* @__PURE__ */ new Set();\n  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {\n    if (structNameSet.has(struct.name)) {\n      return false;\n    }\n    structNameSet.add(struct.name);\n    return true;\n  });\n  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {\n    const key = `${group.name}-${group.binding}`;\n    if (dupeGroupKeySet.has(key)) {\n      return false;\n    }\n    dupeGroupKeySet.add(key);\n    return true;\n  });\n  return { structs, groups };\n}\n\nexport { removeStructAndGroupDuplicates };\n//# sourceMappingURL=removeStructAndGroupDuplicates.mjs.map\n","import { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram.mjs';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups.mjs';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups.mjs';\nimport { generateLayoutHash } from './utils/generateLayoutHash.mjs';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates.mjs';\n\n\"use strict\";\nconst programCache = /* @__PURE__ */ Object.create(null);\nclass GpuProgram {\n  /**\n   * Create a new GpuProgram\n   * @param options - The options for the gpu program\n   */\n  constructor(options) {\n    /**\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    const { fragment, vertex, layout, gpuLayout, name } = options;\n    this.name = name;\n    this.fragment = fragment;\n    this.vertex = vertex;\n    if (fragment.source === vertex.source) {\n      const structsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = structsAndGroups;\n    } else {\n      const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n      const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n    }\n    this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n    this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n    this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);\n    this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);\n    this._generateProgramKey();\n  }\n  // TODO maker this pure\n  _generateProgramKey() {\n    const { vertex, fragment } = this;\n    const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n    this._layoutKey = createIdFromString(bigKey, \"program\");\n  }\n  get attributeData() {\n    this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));\n    return this._attributeData;\n  }\n  /** destroys the program */\n  destroy() {\n    this.gpuLayout = null;\n    this.layout = null;\n    this.structsAndGroups = null;\n    this.fragment = null;\n    this.vertex = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n    if (!programCache[key]) {\n      programCache[key] = new GpuProgram(options);\n    }\n    return programCache[key];\n  }\n}\n\nexport { GpuProgram };\n//# sourceMappingURL=GpuProgram.mjs.map\n","\"use strict\";\nfunction getDefaultUniformValue(type, size) {\n  switch (type) {\n    case \"f32\":\n      return 0;\n    case \"vec2<f32>\":\n      return new Float32Array(2 * size);\n    case \"vec3<f32>\":\n      return new Float32Array(3 * size);\n    case \"vec4<f32>\":\n      return new Float32Array(4 * size);\n    case \"mat2x2<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case \"mat3x3<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case \"mat4x4<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\n\nexport { getDefaultUniformValue };\n//# sourceMappingURL=getDefaultUniformValue.mjs.map\n","import { uid } from '../../../../utils/data/uid.mjs';\nimport { createIdFromString } from '../utils/createIdFromString.mjs';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue.mjs';\n\n\"use strict\";\nconst _UniformGroup = class _UniformGroup {\n  /**\n   * Create a new Uniform group\n   * @param uniformStructures - The structures of the uniform group\n   * @param options - The optional parameters of this uniform group\n   */\n  constructor(uniformStructures, options) {\n    /** used internally to know if a uniform group was used in the last render pass */\n    this._touched = 0;\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"uniform\");\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    this._resourceType = \"uniformGroup\";\n    /** the resource id used internally by the renderer to build bind group keys */\n    this._resourceId = uid(\"resource\");\n    /** used ito identify if this is a uniform group */\n    this.isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    this._dirtyId = 0;\n    // implementing the interface - UniformGroup are not destroyed\n    this.destroyed = false;\n    options = { ..._UniformGroup.defaultOptions, ...options };\n    this.uniformStructures = uniformStructures;\n    const uniforms = {};\n    for (const i in uniformStructures) {\n      const uniformData = uniformStructures[i];\n      uniformData.name = i;\n      uniformData.size = uniformData.size ?? 1;\n      uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));\n      uniforms[i] = uniformData.value;\n    }\n    this.uniforms = uniforms;\n    this._dirtyId = 1;\n    this.ubo = options.ubo;\n    this.isStatic = options.isStatic;\n    this._signature = createIdFromString(Object.keys(uniforms).map(\n      (i) => `${i}-${uniformStructures[i].type}`\n    ).join(\"-\"), \"uniform-group\");\n  }\n  /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n  update() {\n    this._dirtyId++;\n  }\n};\n/** The default options used by the uniform group. */\n_UniformGroup.defaultOptions = {\n  /** if true the UniformGroup is handled as an Uniform buffer object. */\n  ubo: false,\n  /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n  isStatic: false\n};\nlet UniformGroup = _UniformGroup;\n\nexport { UniformGroup };\n//# sourceMappingURL=UniformGroup.mjs.map\n","\"use strict\";\nvar RendererType = /* @__PURE__ */ ((RendererType2) => {\n  RendererType2[RendererType2[\"WEBGL\"] = 1] = \"WEBGL\";\n  RendererType2[RendererType2[\"WEBGPU\"] = 2] = \"WEBGPU\";\n  RendererType2[RendererType2[\"BOTH\"] = 3] = \"BOTH\";\n  return RendererType2;\n})(RendererType || {});\n\nexport { RendererType };\n//# sourceMappingURL=types.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { GlProgram } from '../../gl/shader/GlProgram.mjs';\nimport { BindGroup } from '../../gpu/shader/BindGroup.mjs';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram.mjs';\nimport { RendererType } from '../../types.mjs';\nimport { UniformGroup } from './UniformGroup.mjs';\n\n\"use strict\";\nclass Shader extends EventEmitter {\n  constructor(options) {\n    super();\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    this._uniformBindMap = /* @__PURE__ */ Object.create(null);\n    this._ownedBindGroups = [];\n    let {\n      gpuProgram,\n      glProgram,\n      groups,\n      resources,\n      compatibleRenderers,\n      groupMap\n    } = options;\n    this.gpuProgram = gpuProgram;\n    this.glProgram = glProgram;\n    if (compatibleRenderers === void 0) {\n      compatibleRenderers = 0;\n      if (gpuProgram)\n        compatibleRenderers |= RendererType.WEBGPU;\n      if (glProgram)\n        compatibleRenderers |= RendererType.WEBGL;\n    }\n    this.compatibleRenderers = compatibleRenderers;\n    const nameHash = {};\n    if (!resources && !groups) {\n      resources = {};\n    }\n    if (resources && groups) {\n      throw new Error(\"[Shader] Cannot have both resources and groups\");\n    } else if (!gpuProgram && groups && !groupMap) {\n      throw new Error(\"[Shader] No group map or WebGPU shader provided - consider using resources instead.\");\n    } else if (!gpuProgram && groups && groupMap) {\n      for (const i in groupMap) {\n        for (const j in groupMap[i]) {\n          const uniformName = groupMap[i][j];\n          nameHash[uniformName] = {\n            group: i,\n            binding: j,\n            name: uniformName\n          };\n        }\n      }\n    } else if (gpuProgram && groups && !groupMap) {\n      const groupData = gpuProgram.structsAndGroups.groups;\n      groupMap = {};\n      groupData.forEach((data) => {\n        groupMap[data.group] = groupMap[data.group] || {};\n        groupMap[data.group][data.binding] = data.name;\n        nameHash[data.name] = data;\n      });\n    } else if (resources) {\n      if (!gpuProgram) {\n        groupMap = {};\n        groups = {\n          99: new BindGroup()\n        };\n        this._ownedBindGroups.push(groups[99]);\n        let bindTick = 0;\n        for (const i in resources) {\n          nameHash[i] = { group: 99, binding: bindTick, name: i };\n          groupMap[99] = groupMap[99] || {};\n          groupMap[99][bindTick] = i;\n          bindTick++;\n        }\n      } else {\n        const groupData = gpuProgram.structsAndGroups.groups;\n        groupMap = {};\n        groupData.forEach((data) => {\n          groupMap[data.group] = groupMap[data.group] || {};\n          groupMap[data.group][data.binding] = data.name;\n          nameHash[data.name] = data;\n        });\n      }\n      groups = {};\n      for (const i in resources) {\n        const name = i;\n        let value = resources[i];\n        if (!value.source && !value._resourceType) {\n          value = new UniformGroup(value);\n        }\n        const data = nameHash[name];\n        if (data) {\n          if (!groups[data.group]) {\n            groups[data.group] = new BindGroup();\n            this._ownedBindGroups.push(groups[data.group]);\n          }\n          groups[data.group].setResource(value, data.binding);\n        }\n      }\n    }\n    this.groups = groups;\n    this._uniformBindMap = groupMap;\n    this.resources = this._buildResourceAccessor(groups, nameHash);\n  }\n  /**\n   * Sometimes a resource group will be provided later (for example global uniforms)\n   * In such cases, this method can be used to let the shader know about the group.\n   * @param name - the name of the resource group\n   * @param groupIndex - the index of the group (should match the webGPU shader group location)\n   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n   */\n  addResource(name, groupIndex, bindIndex) {\n    var _a, _b;\n    (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});\n    (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);\n    if (!this.groups[groupIndex]) {\n      this.groups[groupIndex] = new BindGroup();\n      this._ownedBindGroups.push(this.groups[groupIndex]);\n    }\n  }\n  _buildResourceAccessor(groups, nameHash) {\n    const uniformsOut = {};\n    for (const i in nameHash) {\n      const data = nameHash[i];\n      Object.defineProperty(uniformsOut, data.name, {\n        get() {\n          return groups[data.group].getResource(data.binding);\n        },\n        set(value) {\n          groups[data.group].setResource(value, data.binding);\n        }\n      });\n    }\n    return uniformsOut;\n  }\n  /**\n   * Use to destroy the shader when its not longer needed.\n   * It will destroy the resources and remove listeners.\n   * @param destroyPrograms - if the programs should be destroyed as well.\n   * Make sure its not being used by other shaders!\n   */\n  destroy(destroyPrograms = false) {\n    this.emit(\"destroy\", this);\n    if (destroyPrograms) {\n      this.gpuProgram?.destroy();\n      this.glProgram?.destroy();\n    }\n    this.gpuProgram = null;\n    this.glProgram = null;\n    this.removeAllListeners();\n    this._uniformBindMap = null;\n    this._ownedBindGroups.forEach((bindGroup) => {\n      bindGroup.destroy();\n    });\n    this._ownedBindGroups = null;\n    this.resources = null;\n    this.groups = null;\n  }\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new Shader({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n}\n\nexport { Shader };\n//# sourceMappingURL=Shader.mjs.map\n","\"use strict\";\nconst blendModeIds = {\n  normal: 0,\n  add: 1,\n  multiply: 2,\n  screen: 3,\n  overlay: 4,\n  erase: 5,\n  \"normal-npm\": 6,\n  \"add-npm\": 7,\n  \"screen-npm\": 8\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _State = class _State {\n  constructor() {\n    this.data = 0;\n    this.blendMode = \"normal\";\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    if (!!(this.data & 1 << BLEND) !== value) {\n      this.data ^= 1 << BLEND;\n    }\n  }\n  /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    if (!!(this.data & 1 << OFFSET) !== value) {\n      this.data ^= 1 << OFFSET;\n    }\n  }\n  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n  set cullMode(value) {\n    if (value === \"none\") {\n      this.culling = false;\n      return;\n    }\n    this.culling = true;\n    this.clockwiseFrontFace = value === \"front\";\n  }\n  get cullMode() {\n    if (!this.culling) {\n      return \"none\";\n    }\n    return this.clockwiseFrontFace ? \"front\" : \"back\";\n  }\n  /**\n   * Activates culling of polygons.\n   * @default false\n   */\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    if (!!(this.data & 1 << CULLING) !== value) {\n      this.data ^= 1 << CULLING;\n    }\n  }\n  /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n      this.data ^= 1 << DEPTH_TEST;\n    }\n  }\n  /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n      this.data ^= 1 << DEPTH_MASK;\n    }\n  }\n  /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    if (!!(this.data & 1 << WINDING) !== value) {\n      this.data ^= 1 << WINDING;\n    }\n  }\n  /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== \"none\";\n    this._blendMode = value;\n    this._blendModeId = blendModeIds[value] || 0;\n  }\n  /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value;\n    this._polygonOffset = value;\n  }\n  toString() {\n    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n  }\n  /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */\n  static for2d() {\n    const state = new _State();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  }\n};\n_State.default2d = _State.for2d();\nlet State = _State;\n\nexport { State };\n//# sourceMappingURL=State.mjs.map\n","import { nextPow2 } from '../../../../maths/misc/pow2.mjs';\nimport { TextureSource } from './sources/TextureSource.mjs';\nimport { Texture } from './Texture.mjs';\n\n\"use strict\";\nlet count = 0;\nclass TexturePoolClass {\n  /**\n   * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n   */\n  constructor(textureOptions) {\n    this._poolKeyHash = /* @__PURE__ */ Object.create(null);\n    this._texturePool = {};\n    this.textureOptions = textureOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   * @param antialias\n   */\n  createTexture(pixelWidth, pixelHeight, antialias) {\n    const textureSource = new TextureSource({\n      ...this.textureOptions,\n      width: pixelWidth,\n      height: pixelHeight,\n      resolution: 1,\n      antialias,\n      autoGarbageCollect: true\n    });\n    return new Texture({\n      source: textureSource,\n      label: `texturePool_${count++}`\n    });\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param frameWidth - The minimum width of the render texture.\n   * @param frameHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @param antialias\n   * @returns The new render texture.\n   */\n  getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {\n    let po2Width = Math.ceil(frameWidth * resolution - 1e-6);\n    let po2Height = Math.ceil(frameHeight * resolution - 1e-6);\n    po2Width = nextPow2(po2Width);\n    po2Height = nextPow2(po2Height);\n    const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n    if (!this._texturePool[key]) {\n      this._texturePool[key] = [];\n    }\n    let texture = this._texturePool[key].pop();\n    if (!texture) {\n      texture = this.createTexture(po2Width, po2Height, antialias);\n    }\n    texture.source._resolution = resolution;\n    texture.source.width = po2Width / resolution;\n    texture.source.height = po2Height / resolution;\n    texture.source.pixelWidth = po2Width;\n    texture.source.pixelHeight = po2Height;\n    texture.frame.x = 0;\n    texture.frame.y = 0;\n    texture.frame.width = frameWidth;\n    texture.frame.height = frameHeight;\n    texture.updateUvs();\n    this._poolKeyHash[texture.uid] = key;\n    return texture;\n  }\n  /**\n   * Gets extra texture of the same size as input renderTexture\n   * @param texture - The texture to check what size it is.\n   * @param antialias - Whether to use antialias.\n   * @returns A texture that is a power of two\n   */\n  getSameSizeTexture(texture, antialias = false) {\n    const source = texture.source;\n    return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param renderTexture - The renderTexture to free\n   */\n  returnTexture(renderTexture) {\n    const key = this._poolKeyHash[renderTexture.uid];\n    this._texturePool[key].push(renderTexture);\n  }\n  /**\n   * Clears the pool.\n   * @param destroyTextures - Destroy all stored textures.\n   */\n  clear(destroyTextures) {\n    destroyTextures = destroyTextures !== false;\n    if (destroyTextures) {\n      for (const i in this._texturePool) {\n        const textures = this._texturePool[i];\n        if (textures) {\n          for (let j = 0; j < textures.length; j++) {\n            textures[j].destroy(true);\n          }\n        }\n      }\n    }\n    this._texturePool = {};\n  }\n}\nconst TexturePool = new TexturePoolClass();\n\nexport { TexturePool, TexturePoolClass };\n//# sourceMappingURL=TexturePool.mjs.map\n","import { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction addBits(srcParts, parts, name) {\n  if (srcParts) {\n    for (const i in srcParts) {\n      const id = i.toLocaleLowerCase();\n      const part = parts[id];\n      if (part) {\n        let sanitisedPart = srcParts[i];\n        if (i === \"header\") {\n          sanitisedPart = sanitisedPart.replace(/@in\\s+[^;]+;\\s*/g, \"\").replace(/@out\\s+[^;]+;\\s*/g, \"\");\n        }\n        if (name) {\n          part.push(`//----${name}----//`);\n        }\n        part.push(sanitisedPart);\n      } else {\n        warn(`${i} placement hook does not exist in shader`);\n      }\n    }\n  }\n}\n\nexport { addBits };\n//# sourceMappingURL=addBits.mjs.map\n","\"use strict\";\nconst findHooksRx = /\\{\\{(.*?)\\}\\}/g;\nfunction compileHooks(programSrc) {\n  const parts = {};\n  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, \"\")) ?? [];\n  partMatches.forEach((hook) => {\n    parts[hook] = [];\n  });\n  return parts;\n}\n\nexport { compileHooks, findHooksRx };\n//# sourceMappingURL=compileHooks.mjs.map\n","\"use strict\";\nfunction extractInputs(fragmentSource, out) {\n  let match;\n  const regex = /@in\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction compileInputs(fragments, template, sort = false) {\n  const results = [];\n  extractInputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractInputs(fragment.header, results);\n    }\n  });\n  const mainInput = results;\n  if (sort) {\n    mainInput.sort();\n  }\n  const finalString = mainInput.map((inValue, i) => `       @location(${i}) ${inValue},`).join(\"\\n\");\n  let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, \"\");\n  cleanedString = cleanedString.replace(\"{{in}}\", `\n${finalString}\n`);\n  return cleanedString;\n}\n\nexport { compileInputs };\n//# sourceMappingURL=compileInputs.mjs.map\n","\"use strict\";\nfunction extractOutputs(fragmentSource, out) {\n  let match;\n  const regex = /@out\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction extractVariableName(value) {\n  const regex = /\\b(\\w+)\\s*:/g;\n  const match = regex.exec(value);\n  return match ? match[1] : \"\";\n}\nfunction stripVariable(value) {\n  const regex = /@.*?\\s+/g;\n  return value.replace(regex, \"\");\n}\nfunction compileOutputs(fragments, template) {\n  const results = [];\n  extractOutputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractOutputs(fragment.header, results);\n    }\n  });\n  let index = 0;\n  const mainStruct = results.sort().map((inValue) => {\n    if (inValue.indexOf(\"builtin\") > -1) {\n      return inValue;\n    }\n    return `@location(${index++}) ${inValue}`;\n  }).join(\",\\n\");\n  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join(\"\\n\");\n  const mainEnd = `return VSOutput(\n                ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(\",\\n\")});`;\n  let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n  compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n  compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n  compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n  return compiledCode;\n}\n\nexport { compileOutputs };\n//# sourceMappingURL=compileOutputs.mjs.map\n","\"use strict\";\nfunction injectBits(templateSrc, fragmentParts) {\n  let out = templateSrc;\n  for (const i in fragmentParts) {\n    const parts = fragmentParts[i];\n    const toInject = parts.join(\"\\n\");\n    if (toInject.length) {\n      out = out.replace(`{{${i}}}`, `//-----${i} START-----//\n${parts.join(\"\\n\")}\n//----${i} FINISH----//`);\n    } else {\n      out = out.replace(`{{${i}}}`, \"\");\n    }\n  }\n  return out;\n}\n\nexport { injectBits };\n//# sourceMappingURL=injectBits.mjs.map\n","import { addBits } from './utils/addBits.mjs';\nimport { compileHooks } from './utils/compileHooks.mjs';\nimport { compileInputs } from './utils/compileInputs.mjs';\nimport { compileOutputs } from './utils/compileOutputs.mjs';\nimport { injectBits } from './utils/injectBits.mjs';\n\n\"use strict\";\nconst cacheMap = /* @__PURE__ */ Object.create(null);\nconst bitCacheMap = /* @__PURE__ */ new Map();\nlet CACHE_UID = 0;\nfunction compileHighShader({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n  cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileHighShaderGl({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileInputsAndOutputs(template, bits) {\n  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n  compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n  return {\n    vertex: compiledVertex,\n    fragment: compiledFragment\n  };\n}\nfunction generateCacheId(template, bits) {\n  return bits.map((highFragment) => {\n    if (!bitCacheMap.has(highFragment)) {\n      bitCacheMap.set(highFragment, CACHE_UID++);\n    }\n    return bitCacheMap.get(highFragment);\n  }).sort((a, b) => a - b).join(\"-\") + template.vertex + template.fragment;\n}\nfunction compileBits(vertex, fragment, bits) {\n  const vertexParts = compileHooks(vertex);\n  const fragmentParts = compileHooks(fragment);\n  bits.forEach((shaderBit) => {\n    addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n  });\n  return {\n    vertex: injectBits(vertex, vertexParts),\n    fragment: injectBits(fragment, fragmentParts)\n  };\n}\n\nexport { compileHighShader, compileHighShaderGl };\n//# sourceMappingURL=compileHighShader.mjs.map\n","\"use strict\";\nconst vertexGPUTemplate = (\n  /* wgsl */\n  `\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`\n);\nconst fragmentGPUTemplate = (\n  /* wgsl */\n  `\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`\n);\nconst vertexGlTemplate = (\n  /* glsl */\n  `\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`\n);\nconst fragmentGlTemplate = (\n  /* glsl */\n  `\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`\n);\n\nexport { fragmentGPUTemplate, fragmentGlTemplate, vertexGPUTemplate, vertexGlTemplate };\n//# sourceMappingURL=defaultProgramTemplate.mjs.map\n","\"use strict\";\nconst globalUniformsBit = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    )\n  }\n};\nconst globalUniformsUBOBitGl = {\n  name: \"global-uniforms-ubo-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    )\n  }\n};\nconst globalUniformsBitGl = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    )\n  }\n};\n\nexport { globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl };\n//# sourceMappingURL=globalUniformsBit.mjs.map\n","import { GlProgram } from '../renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram.mjs';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader.mjs';\nimport { fragmentGPUTemplate, vertexGPUTemplate, vertexGlTemplate, fragmentGlTemplate } from './defaultProgramTemplate.mjs';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit.mjs';\n\n\"use strict\";\nfunction compileHighShaderGpuProgram({ bits, name }) {\n  const source = compileHighShader({\n    template: {\n      fragment: fragmentGPUTemplate,\n      vertex: vertexGPUTemplate\n    },\n    bits: [\n      globalUniformsBit,\n      ...bits\n    ]\n  });\n  return GpuProgram.from({\n    name,\n    vertex: {\n      source: source.vertex,\n      entryPoint: \"main\"\n    },\n    fragment: {\n      source: source.fragment,\n      entryPoint: \"main\"\n    }\n  });\n}\nfunction compileHighShaderGlProgram({ bits, name }) {\n  return new GlProgram({\n    name,\n    ...compileHighShaderGl({\n      template: {\n        vertex: vertexGlTemplate,\n        fragment: fragmentGlTemplate\n      },\n      bits: [\n        globalUniformsBitGl,\n        ...bits\n      ]\n    })\n  });\n}\n\nexport { compileHighShaderGlProgram, compileHighShaderGpuProgram };\n//# sourceMappingURL=compileHighShaderToProgram.mjs.map\n","\"use strict\";\nconst colorBit = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            @in aColor: vec4<f32>;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\nconst colorBitGl = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            in vec4 aColor;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\n\nexport { colorBit, colorBitGl };\n//# sourceMappingURL=colorBit.mjs.map\n","\"use strict\";\nconst textureBatchBitGpuCache = {};\nfunction generateBindingSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n    src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n  } else {\n    let bindingIndex = 0;\n    for (let i = 0; i < maxTextures; i++) {\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n    }\n  }\n  return src.join(\"\\n\");\n}\nfunction generateSampleSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n  } else {\n    src.push(\"switch vTextureId {\");\n    for (let i = 0; i < maxTextures; i++) {\n      if (i === maxTextures - 1) {\n        src.push(`  default:{`);\n      } else {\n        src.push(`  case ${i}:{`);\n      }\n      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n      src.push(`      break;}`);\n    }\n    src.push(`}`);\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBit(maxTextures) {\n  if (!textureBatchBitGpuCache[maxTextures]) {\n    textureBatchBitGpuCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${generateBindingSrc(16)}\n            `,\n        main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${generateSampleSrc(16)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGpuCache[maxTextures];\n}\nconst textureBatchBitGlCache = {};\nfunction generateSampleGlSrc(maxTextures) {\n  const src = [];\n  for (let i = 0; i < maxTextures; i++) {\n    if (i > 0) {\n      src.push(\"else\");\n    }\n    if (i < maxTextures - 1) {\n      src.push(`if(vTextureId < ${i}.5)`);\n    }\n    src.push(\"{\");\n    src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n    src.push(\"}\");\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBitGl(maxTextures) {\n  if (!textureBatchBitGlCache[maxTextures]) {\n    textureBatchBitGlCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,\n        main: `\n    \n                ${generateSampleGlSrc(16)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGlCache[maxTextures];\n}\n\nexport { generateTextureBatchBit, generateTextureBatchBitGl };\n//# sourceMappingURL=generateTextureBatchBit.mjs.map\n","\"use strict\";\nconst roundPixelsBit = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\nconst roundPixelsBitGl = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\n\nexport { roundPixelsBit, roundPixelsBitGl };\n//# sourceMappingURL=roundPixelsBit.mjs.map\n","\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    // batch specific..\n    this.vertexSize = 4;\n    this.indexSize = 6;\n    this.location = 0;\n    // location in the buffer\n    this.batcher = null;\n    this.batch = null;\n    this.roundPixels = 0;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const sprite = this.renderable;\n    const texture = this.texture;\n    const wt = sprite.groupTransform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const bounds = this.bounds;\n    const w0 = bounds.maxX;\n    const w1 = bounds.minX;\n    const h0 = bounds.maxY;\n    const h1 = bounds.minY;\n    const uvs = texture.uvs;\n    const argb = sprite.groupColorAlpha;\n    const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n    float32View[index + 0] = a * w1 + c * h1 + tx;\n    float32View[index + 1] = d * h1 + b * w1 + ty;\n    float32View[index + 2] = uvs.x0;\n    float32View[index + 3] = uvs.y0;\n    uint32View[index + 4] = argb;\n    uint32View[index + 5] = textureIdAndRound;\n    float32View[index + 6] = a * w0 + c * h1 + tx;\n    float32View[index + 7] = d * h1 + b * w0 + ty;\n    float32View[index + 8] = uvs.x1;\n    float32View[index + 9] = uvs.y1;\n    uint32View[index + 10] = argb;\n    uint32View[index + 11] = textureIdAndRound;\n    float32View[index + 12] = a * w0 + c * h0 + tx;\n    float32View[index + 13] = d * h0 + b * w0 + ty;\n    float32View[index + 14] = uvs.x2;\n    float32View[index + 15] = uvs.y2;\n    uint32View[index + 16] = argb;\n    uint32View[index + 17] = textureIdAndRound;\n    float32View[index + 18] = a * w1 + c * h0 + tx;\n    float32View[index + 19] = d * h0 + b * w1 + ty;\n    float32View[index + 20] = uvs.x3;\n    float32View[index + 21] = uvs.y3;\n    uint32View[index + 22] = argb;\n    uint32View[index + 23] = textureIdAndRound;\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    indexBuffer[index] = indicesOffset + 0;\n    indexBuffer[index + 1] = indicesOffset + 1;\n    indexBuffer[index + 2] = indicesOffset + 2;\n    indexBuffer[index + 3] = indicesOffset + 0;\n    indexBuffer[index + 4] = indicesOffset + 2;\n    indexBuffer[index + 5] = indicesOffset + 3;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this.batcher = null;\n    this.batch = null;\n    this.bounds = null;\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n"],"names":["idCounts","idHash","createIdFromString","value","groupId","id","context","getTestContext","DOMAdapter","maxFragmentPrecision","getMaxFragmentPrecision","gl","addProgramDefines","src","isES300","isFragment","ensurePrecision","options","maxSupportedPrecision","precision","insertVersion","fragmentNameCache","VertexNameCache","setProgramName","name","nameCache","stripVersion","processes","programCache","_GlProgram","preprocessorOptions","fragment","vertex","processKey","processOptions","key","GlProgram","attributeFormatData","getAttributeInfoFromFormat","format","WGSL_TO_VERTEX_TYPES","extractAttributesFromGpuProgram","source","entryPoint","results","mainVertStart","arrowFunctionStart","functionArgsSubstring","inputsRegex","match","extractStructAndGroups","wgsl","linePattern","groupPattern","bindingPattern","namePattern","typePattern","structPattern","structMemberPattern","structName","groups","_a","item","structs","_b","struct","members","acc","member","name2","type","group","ShaderStage","ShaderStage2","generateGpuLayoutGroups","layout","i","generateLayoutHash","removeStructAndGroupDuplicates","vertexStructsAndGroups","fragmentStructsAndGroups","structNameSet","dupeGroupKeySet","GpuProgram","gpuLayout","structsAndGroups","bigKey","getDefaultUniformValue","size","_UniformGroup","uniformStructures","uid","uniforms","uniformData","UniformGroup","RendererType","RendererType2","Shader","EventEmitter","gpuProgram","glProgram","resources","compatibleRenderers","groupMap","nameHash","j","uniformName","groupData","data","BindGroup","bindTick","groupIndex","bindIndex","uniformsOut","destroyPrograms","bindGroup","gpu","rest","blendModeIds","BLEND","OFFSET","CULLING","DEPTH_TEST","WINDING","DEPTH_MASK","_State","state","State","count","TexturePoolClass","textureOptions","pixelWidth","pixelHeight","antialias","textureSource","TextureSource","Texture","frameWidth","frameHeight","resolution","po2Width","po2Height","nextPow2","texture","renderTexture","destroyTextures","textures","TexturePool","addBits","srcParts","parts","part","sanitisedPart","warn","findHooksRx","compileHooks","programSrc","hook","extractInputs","fragmentSource","out","regex","compileInputs","fragments","template","sort","mainInput","finalString","inValue","cleanedString","extractOutputs","extractVariableName","stripVariable","compileOutputs","index","mainStruct","mainStart","mainEnd","compiledCode","injectBits","templateSrc","fragmentParts","cacheMap","bitCacheMap","CACHE_UID","compileHighShader","bits","cacheId","generateCacheId","compileInputsAndOutputs","compileBits","compileHighShaderGl","vertexFragments","shaderBit","v","fragmentFragments","compiledVertex","compiledFragment","highFragment","a","b","vertexParts","vertexGPUTemplate","fragmentGPUTemplate","vertexGlTemplate","fragmentGlTemplate","globalUniformsBit","globalUniformsBitGl","compileHighShaderGpuProgram","compileHighShaderGlProgram","colorBit","colorBitGl","textureBatchBitGpuCache","generateBindingSrc","maxTextures","bindingIndex","generateSampleSrc","generateTextureBatchBit","textureBatchBitGlCache","generateSampleGlSrc","generateTextureBatchBitGl","roundPixelsBit","roundPixelsBitGl","localUniformBit","localUniformBitGroup2","localUniformBitGl","BatchableSprite","float32View","uint32View","textureId","sprite","wt","d","tx","ty","bounds","w0","w1","h0","h1","uvs","argb","textureIdAndRound","indexBuffer","indicesOffset","color32BitToUniform","abgr","offset","alpha"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37]}