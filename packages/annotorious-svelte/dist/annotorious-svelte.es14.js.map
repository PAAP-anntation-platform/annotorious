{"version":3,"file":"annotorious-svelte.es14.js","sources":["../../../node_modules/svelte/src/runtime/internal/scheduler.js"],"sourcesContent":["import { run_all } from './utils.js';\nimport { current_component, set_current_component } from './lifecycle.js';\n\nexport const dirty_components = [];\nexport const intros = { enabled: false };\nexport const binding_callbacks = [];\n\nlet render_callbacks = [];\n\nconst flush_callbacks = [];\n\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\n\nlet update_scheduled = false;\n\n/** @returns {void} */\nexport function schedule_update() {\n\tif (!update_scheduled) {\n\t\tupdate_scheduled = true;\n\t\tresolved_promise.then(flush);\n\t}\n}\n\n/** @returns {Promise<void>} */\nexport function tick() {\n\tschedule_update();\n\treturn resolved_promise;\n}\n\n/** @returns {void} */\nexport function add_render_callback(fn) {\n\trender_callbacks.push(fn);\n}\n\n/** @returns {void} */\nexport function add_flush_callback(fn) {\n\tflush_callbacks.push(fn);\n}\n\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\n\nlet flushidx = 0; // Do *not* move this inside the flush() function\n\n/** @returns {void} */\nexport function flush() {\n\t// Do not reenter flush while dirty components are updated, as this can\n\t// result in an infinite loop. Instead, let the inner flush handle it.\n\t// Reentrancy is ok afterwards for bindings etc.\n\tif (flushidx !== 0) {\n\t\treturn;\n\t}\n\tconst saved_component = current_component;\n\tdo {\n\t\t// first, call beforeUpdate functions\n\t\t// and update components\n\t\ttry {\n\t\t\twhile (flushidx < dirty_components.length) {\n\t\t\t\tconst component = dirty_components[flushidx];\n\t\t\t\tflushidx++;\n\t\t\t\tset_current_component(component);\n\t\t\t\tupdate(component.$$);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// reset dirty state to not end up in a deadlocked state and then rethrow\n\t\t\tdirty_components.length = 0;\n\t\t\tflushidx = 0;\n\t\t\tthrow e;\n\t\t}\n\t\tset_current_component(null);\n\t\tdirty_components.length = 0;\n\t\tflushidx = 0;\n\t\twhile (binding_callbacks.length) binding_callbacks.pop()();\n\t\t// then, once components are updated, call\n\t\t// afterUpdate functions. This may cause\n\t\t// subsequent updates...\n\t\tfor (let i = 0; i < render_callbacks.length; i += 1) {\n\t\t\tconst callback = render_callbacks[i];\n\t\t\tif (!seen_callbacks.has(callback)) {\n\t\t\t\t// ...so guard against infinite loops\n\t\t\t\tseen_callbacks.add(callback);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t\trender_callbacks.length = 0;\n\t} while (dirty_components.length);\n\twhile (flush_callbacks.length) {\n\t\tflush_callbacks.pop()();\n\t}\n\tupdate_scheduled = false;\n\tseen_callbacks.clear();\n\tset_current_component(saved_component);\n}\n\n/** @returns {void} */\nfunction update($$) {\n\tif ($$.fragment !== null) {\n\t\t$$.update();\n\t\trun_all($$.before_update);\n\t\tconst dirty = $$.dirty;\n\t\t$$.dirty = [-1];\n\t\t$$.fragment && $$.fragment.p($$.ctx, dirty);\n\t\t$$.after_update.forEach(add_render_callback);\n\t}\n}\n\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function flush_render_callbacks(fns) {\n\tconst filtered = [];\n\tconst targets = [];\n\trender_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));\n\ttargets.forEach((c) => c());\n\trender_callbacks = filtered;\n}\n"],"names":["dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","update_scheduled","schedule_update","flush","add_render_callback","fn","seen_callbacks","flushidx","saved_component","current_component","component","set_current_component","update","e","i","callback","$$","run_all","dirty","flush_render_callbacks","fns","filtered","targets","c"],"mappings":";;AAGY,MAACA,IAAmB,CAAG,GAEtBC,IAAoB,CAAG;AAEpC,IAAIC,IAAmB,CAAA;AAEvB,MAAMC,IAAkB,CAAA,GAElBC,IAAmC,wBAAQ;AAEjD,IAAIC,IAAmB;AAGhB,SAASC,IAAkB;AACjC,EAAKD,MACJA,IAAmB,IACnBD,EAAiB,KAAKG,CAAK;AAE7B;AASO,SAASC,EAAoBC,GAAI;AACvC,EAAAP,EAAiB,KAAKO,CAAE;AACzB;AAyBA,MAAMC,IAAiB,oBAAI;AAE3B,IAAIC,IAAW;AAGR,SAASJ,IAAQ;AAIvB,MAAII,MAAa;AAChB;AAED,QAAMC,IAAkBC;AACxB,KAAG;AAGF,QAAI;AACH,aAAOF,IAAWX,EAAiB,UAAQ;AAC1C,cAAMc,IAAYd,EAAiBW,CAAQ;AAC3C,QAAAA,KACAI,EAAsBD,CAAS,GAC/BE,EAAOF,EAAU,EAAE;AAAA,MACnB;AAAA,IACD,SAAQG,GAAG;AAEX,YAAAjB,EAAiB,SAAS,GAC1BW,IAAW,GACLM;AAAA,IACN;AAID,SAHAF,EAAsB,IAAI,GAC1Bf,EAAiB,SAAS,GAC1BW,IAAW,GACJV,EAAkB;AAAQ,MAAAA,EAAkB,IAAK,EAAA;AAIxD,aAASiB,IAAI,GAAGA,IAAIhB,EAAiB,QAAQgB,KAAK,GAAG;AACpD,YAAMC,IAAWjB,EAAiBgB,CAAC;AACnC,MAAKR,EAAe,IAAIS,CAAQ,MAE/BT,EAAe,IAAIS,CAAQ,GAC3BA;IAED;AACD,IAAAjB,EAAiB,SAAS;AAAA,EAC5B,SAAUF,EAAiB;AAC1B,SAAOG,EAAgB;AACtB,IAAAA,EAAgB,IAAG;AAEpB,EAAAE,IAAmB,IACnBK,EAAe,MAAK,GACpBK,EAAsBH,CAAe;AACtC;AAGA,SAASI,EAAOI,GAAI;AACnB,MAAIA,EAAG,aAAa,MAAM;AACzB,IAAAA,EAAG,OAAM,GACTC,EAAQD,EAAG,aAAa;AACxB,UAAME,IAAQF,EAAG;AACjB,IAAAA,EAAG,QAAQ,CAAC,EAAE,GACdA,EAAG,YAAYA,EAAG,SAAS,EAAEA,EAAG,KAAKE,CAAK,GAC1CF,EAAG,aAAa,QAAQZ,CAAmB;AAAA,EAC3C;AACF;AAOO,SAASe,EAAuBC,GAAK;AAC3C,QAAMC,IAAW,CAAA,GACXC,IAAU,CAAA;AAChB,EAAAxB,EAAiB,QAAQ,CAACyB,MAAOH,EAAI,QAAQG,CAAC,MAAM,KAAKF,EAAS,KAAKE,CAAC,IAAID,EAAQ,KAAKC,CAAC,CAAE,GAC5FD,EAAQ,QAAQ,CAACC,MAAMA,EAAG,CAAA,GAC1BzB,IAAmBuB;AACpB;","x_google_ignoreList":[0]}